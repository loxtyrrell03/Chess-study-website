<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Chess Study Planner — Cloud Sync</title>
<script src="https://cdn.tailwindcss.com"></script>
<meta name="color-scheme" content="dark light"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<style>
  .no-select{user-select:none;-webkit-user-select:none}
  .drag-ghost{opacity:.4}
  .drag-over{outline:2px dashed rgba(56,189,248,.9); outline-offset:4px}
  .row-handle{cursor:grab}
  .row-handle:active{cursor:grabbing}
  .btn-xs{font-size:.72rem; padding:.25rem .45rem; border-radius:.45rem; border:1px solid rgb(51,65,85); background:#0b1220}
  .btn-xxs{font-size:.68rem; padding:.2rem .4rem; border-radius:.35rem; border:1px solid rgb(51,65,85); background:#0b1220}
  .link-card{display:flex;align-items:center;gap:.6rem;padding:.55rem .75rem;border-radius:.75rem;border:1px solid rgb(51,65,85);background:rgba(15,23,42,.6)}
  .link-card:hover{background:rgba(30,41,59,.7)}
  .link-icon{width:18px;height:18px;display:inline-block}
  .glow{box-shadow:0 0 0 2px rgba(56,189,248,.35),0 0 18px rgba(56,189,248,.45) inset}

  /* Split layout */
  #split{display:flex; gap:12px; align-items:stretch; --leftRatio:66%;}
  #leftPane{flex: 0 0 var(--leftRatio); min-width:360px}
  #splitHandle{
    width:8px; border-radius:6px; background:linear-gradient(180deg,#0ea5e9,#0284c7);
    opacity:.65; cursor:col-resize; align-self:stretch; position:relative;
  }
  #splitHandle:hover{opacity:.95}
  #splitHandle::after{
    content:""; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:2px; height:36px; background:rgba(255,255,255,.85); border-radius:2px; box-shadow:0 0 10px rgba(255,255,255,.6);
  }
  #rightPane{flex: 1 1 auto; min-width:260px; max-width:520px}
  #split.collapsed #rightPane, #split.collapsed #splitHandle{display:none}
  #split.collapsed #leftPane{flex:1 1 auto; min-width:0}

  @media (max-width: 980px){
    #split{display:block}
    #splitHandle{display:none}
    #leftPane, #rightPane{width:100%}
  }

  @media print{ .no-print{display:none!important} body{background:#fff} }

  /* Floating analysis launcher + board window */
  #floatBtn{
    position:fixed; bottom:24px; right:24px; width:58px; height:58px;
    border-radius:50%; background:linear-gradient(135deg,#0284c7,#0ea5e9);
    display:flex; align-items:center; justify-content:center; color:#fff;
    box-shadow:0 10px 25px rgba(2,132,199,.35); cursor:grab; z-index:50;
  }
  #floatBtn:active{cursor:grabbing}
  #floatBtn svg{width:28px; height:28px}

  #boardWin{
    position:fixed; bottom:96px; right:36px; width:560px; height:620px;
    background:#0b1220; border:1px solid #1f2a44; border-radius:14px;
    box-shadow:0 16px 40px rgba(2,132,199,.35); z-index:60; display:none;
  }
  #boardHeader{
    height:44px; display:flex; align-items:center; justify-content:space-between;
    padding:0 10px; background:linear-gradient(180deg,rgba(20,31,53,.9),rgba(10,17,32,.95));
    border-bottom:1px solid #1f2a44; cursor:grab; border-top-left-radius:14px; border-top-right-radius:14px;
  }
  #boardHeader:active{cursor:grabbing}
  #boardContent{position:absolute; inset:44px 0 0 0; display:flex; flex-direction:column}
  #boardToolbar{padding:8px 10px; display:flex; gap:8px; align-items:center; border-bottom:1px solid #1f2a44}
  #boardIframeWrap{position:relative; flex:1}
  #boardIframe{position:absolute; inset:0; width:100%; height:100%; border:0; border-bottom-left-radius:14px; border-bottom-right-radius:14px}

  /* Minimized state */
  #boardWin.minimized{ height:44px !important; }
  #boardWin.minimized #boardContent{ display:none; }

  /* resize handles */
  .resizer{position:absolute; background:transparent}
  .resizer.e{cursor:ew-resize; top:8px; bottom:8px; right:-3px; width:6px}
  .resizer.s{cursor:ns-resize; left:8px; right:8px; bottom:-3px; height:6px}
  .resizer.se{cursor:nwse-resize; right:-3px; bottom:-3px; width:10px; height:10px; border-bottom-right-radius:10px}

  /* Minimal outline */
  .outline-row{padding:.6rem .4rem; border-bottom:1px solid rgba(51,65,85,.6)}
  .outline-row:hover{background:rgba(30,41,59,.35)}
  .outline-active{background:rgba(2,132,199,.15) !important; box-shadow:inset 0 0 0 1px rgba(56,189,248,.6)}
  .chip{padding:.35rem .65rem; border-radius:9999px; border:1px solid rgba(51,65,85,.8); display:inline-flex; gap:.35rem; align-items:center; background:rgba(15,23,42,.5)}
  .chip:hover{background:rgba(30,41,59,.6)}
  .chip-active{border-color:rgba(56,189,248,.85); box-shadow:0 0 0 2px rgba(56,189,248,.35); background:rgba(2,132,199,.18); color:#e2f3ff}

  /* Inline outline editing */
  .outline-edit{display:flex; align-items:center; gap:.5rem; width:100%}
  .outline-edit input[type="text"]{min-width:0}
  .inline-field{background:transparent; border:1px solid rgba(56,189,248,.55); border-radius:.5rem; padding:.25rem .5rem}
  .inline-number{width:4.5rem}
  .inline-select{height:30px}
</style>
</head>
<body class="min-h-screen bg-slate-950 text-slate-100">
<div class="max-w-5xl mx-auto px-4 py-6">

  <!-- Header -->
  <header class="mb-6 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between no-print">
    <h1 class="text-2xl sm:text-3xl font-bold tracking-tight">Chess Study Planner</h1>

    <!-- Auth controls -->
    <div class="flex flex-wrap items-center gap-2">
      <div id="authArea" class="flex items-center gap-2">
        <button id="authOpenBtn" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Sign in / Sign up</button>
        <div id="userBadge" class="hidden items-center gap-2">
          <span id="userEmail" class="text-sm text-slate-300"></span>
          <button id="signOutBtn" class="px-3 py-2 rounded-xl bg-rose-600 hover:bg-rose-500">Sign out</button>
        </div>
      </div>
      <select id="presetSelect" class="bg-slate-900 border border-slate-700 rounded-xl px-3 py-2 text-sm">
        <option value="BOTH">Both (90m)</option>
        <option value="A">Session A (45m)</option>
        <option value="B">Session B (45m)</option>
      </select>
      <span id="cloudStatus" class="text-xs text-slate-400">Local mode</span>
    </div>
  </header>

  <!-- Progress -->
  <section class="mb-4 no-print">
    <div class="flex items-center justify-between mb-1">
      <div class="text-xs uppercase tracking-wide text-slate-400">Progress — drag anywhere to jump</div>
      <div id="progressPct" class="text-xs text-slate-300">0%</div>
    </div>
    <div id="progressHost" class="relative w-full h-6 bg-slate-800 rounded-2xl overflow-hidden border border-sky-600/50 glow no-select">
      <div id="progressFill" class="absolute left-0 top-0 bottom-0 bg-sky-500/70 transition-[width]" style="width:0%"></div>
      <div id="progressSegments" class="absolute inset-0 flex"></div>
      <div id="progressTicks" class="absolute inset-0 pointer-events-none"></div>
      <div id="scrubOverlay" class="absolute inset-0 cursor-pointer"></div>
    </div>
    <div id="legend" class="mt-2 flex flex-wrap gap-2 text-sm"></div>
  </section>

  <!-- Controls -->
  <section class="flex flex-wrap items-center gap-3 mb-3 no-print">
    <button id="startBtn" class="px-4 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 shadow-sm">Start Study Session</button>
    <button id="prevBtn" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">◀ Prev</button>
    <button id="nextBtn" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700">Next ▶</button>
    <button id="resetBtn" class="ml-auto px-3 py-2 rounded-xl bg-slate-900 hover:bg-slate-800 border border-slate-700">Reset</button>
    <button id="showOutlineBtn" class="px-3 py-2 rounded-xl bg-slate-800 border border-slate-700 hover:bg-slate-700 hidden">Show Outline ▸</button>
  </section>

  <!-- Split layout -->
  <div id="split">
    <!-- LEFT: CURRENT -->
    <section id="leftPane">
      <div class="bg-slate-900 border border-slate-800 rounded-2xl p-5 shadow-inner">
        <div class="flex items-center justify-between gap-3">
          <div>
            <div class="text-xs uppercase tracking-wide text-slate-400">Current Section</div>
            <h2 id="currentTitle" class="text-2xl font-semibold mt-1">—</h2>
          </div>
          <div class="flex items-center gap-2">
            <button id="editSectionBtn" class="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700 text-sm">Edit Section</button>
            <div id="clock" class="text-3xl font-mono tabular-nums">00:00</div>
          </div>
        </div>

        <!-- LINK WIDGET SHELF (shown only in edit mode) -->
        <div id="shelfWrap" class="mt-4 hidden">
          <div class="flex items-center justify-between">
            <h3 class="text-sm uppercase tracking-wide text-slate-400">Link Widgets</h3>
            <div class="flex items-center gap-2">
              <button id="addWidgetBtn" class="btn-xs">+ New Widget</button>
              <button id="resetShelfBtn" class="btn-xs">Reset Shelf</button>
            </div>
          </div>
          <div id="linkShelf" class="mt-2 flex gap-2 overflow-x-auto p-2 rounded-xl bg-slate-950 border border-slate-800"></div>
          <div class="text-xs text-slate-400 mt-1">Drag a widget into the current section.</div>
        </div>

        <!-- Links in CURRENT SECTION -->
        <div id="linksWrap" class="mt-4">
          <div class="flex items-center justify-between">
            <div class="text-sm text-slate-300">Links in this section</div>
            <button id="clearSectionLinks" class="btn-xs hidden">Clear</button>
          </div>
          <div id="links" class="mt-2 flex flex-wrap gap-2 p-2 rounded-xl bg-slate-950 border border-slate-800 min-h-[44px]"></div>
        </div>

        <!-- Optional description -->
        <div class="mt-4">
          <label class="text-sm text-slate-300">Section notes (optional)</label>
          <textarea id="sectionDesc" class="w-full mt-1 bg-slate-950 border border-slate-800 rounded-xl p-3 text-sm" placeholder="Add notes, mini-checklist, links…"></textarea>
        </div>
      </div>
    </section>

    <!-- DRAG HANDLE -->
    <div id="splitHandle" class="no-print"></div>

    <!-- RIGHT: OUTLINE -->
    <aside id="rightPane">
      <div class="bg-slate-900 border border-slate-800 rounded-2xl p-4 h-full flex flex-col">
        <div class="flex items-center justify-between">
          <h3 class="text-sm uppercase tracking-wide text-slate-400">Session Outline</h3>
          <button id="collapseOutlineBtn" class="text-xs px-2 py-1 rounded-md bg-slate-800 border border-slate-700 hover:bg-slate-700">▾ Hide</button>
        </div>

        <ul id="outline" class="mt-3 flex-1 overflow-auto"></ul>

        <div class="mt-3 flex items-center gap-2">
          <button id="addOutlineItem" class="px-3 py-2 rounded-xl bg-slate-800 border border-slate-700 hover:bg-slate-700 text-sm">+ Add Section</button>
          <div id="totalMins" class="ml-auto text-xs text-slate-400">Total: 0 minutes</div>
        </div>
      </div>
    </aside>
  </div>

  <footer class="mt-10 text-center text-xs text-slate-500 no-print">
    Minimal, keyboard-friendly session manager. ♟️
  </footer>
</div>

<!-- Floating analysis launcher -->
<button id="floatBtn" class="no-print" title="Live Lichess analysis">
  <svg viewBox="0 0 24 24" fill="none"><path d="M6 7c2.5-3.5 9-3.5 12 0 3 3.5 2 9-3 12-3 2-8 0-9-4" stroke="#fff" stroke-width="2" stroke-linecap="round"/></svg>
</button>

<!-- Draggable / resizable analysis window -->
<div id="boardWin" class="no-print" aria-live="polite">
  <div id="boardHeader" class="no-select">
    <div class="flex items-center gap-2">
      <span class="text-sky-300 font-semibold">Live Analysis Board</span>
      <span class="text-xs text-slate-400">(/embed/analysis)</span>
    </div>
    <div class="flex items-center gap-2">
      <button id="minimizeBoard" class="text-xs px-2 py-1 rounded-md bg-slate-800 border border-slate-700 hover:bg-slate-700" type="button" aria-expanded="true">Minimize</button>
      <button id="closeBoard" class="text-xs px-2 py-1 rounded-md bg-rose-600 hover:bg-rose-500" type="button" aria-label="Close analysis window">Close</button>
    </div>
  </div>
  <div id="boardContent">
    <div id="boardToolbar" class="text-sm">
      <input id="fenBar" class="flex-1 bg-slate-950 border border-slate-800 rounded-lg px-2 py-1" placeholder="FEN to load"/>
      <button id="applyFen" class="px-2 py-1 rounded-lg bg-sky-600 hover:bg-sky-500" type="button">Load FEN</button>
      <button id="openViewer" class="px-2 py-1 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700" type="button">Open Game Viewer</button>
      <a id="popOut" target="_blank" rel="noopener" class="px-2 py-1 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700" href="#">Open in new tab</a>
    </div>
    <div id="boardIframeWrap">
      <iframe id="boardIframe" title="Lichess analysis"></iframe>
    </div>
  </div>
  <div class="resizer e" aria-hidden="true"></div>
  <div class="resizer s" aria-hidden="true"></div>
  <div class="resizer se" aria-hidden="true"></div>
</div>

<!-- ---------- Auth Modal (Google + Email/Password) ---------- -->
<div id="authModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm hidden items-center justify-center z-[100]">
  <div class="w-[92vw] max-w-md bg-slate-900 border border-slate-700 rounded-2xl p-5">
    <div class="flex items-start justify-between mb-4">
      <h3 id="authModalTitle" class="text-xl font-semibold">Sign in</h3>
      <button id="closeAuthModal" class="text-slate-400 hover:text-slate-200" title="Close">✕</button>
    </div>

    <div class="space-y-3">
      <button id="googleAuthBtn" class="w-full px-3 py-2 rounded-xl bg-white text-slate-900 hover:bg-slate-200 flex items-center justify-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.6 20.5H42V20H24v8h11.3C33.5 31.9 29.2 35 24 35c-6.1 0-11-4.9-11-11s4.9-11 11-11c2.8 0 5.4 1.1 7.4 2.9l5.7-5.7C33.2 7.1 28.8 5 24 5 12.9 5 4 13.9 4 25s8.9 20 20 20 20-8.9 20-20c0-1.3-.1-2.7-.4-4z"/><path fill="#FF3D00" d="M6.3 14.7l6.6 4.8C14.7 16.6 19 13 24 13c2.8 0 5.4 1.1 7.4 2.9l5.7-5.7C33.2 7.1 28.8 5 24 5 16.4 5 10 9.1 6.3 14.7z"/><path fill="#4CAF50" d="M24 45c5.1 0 9.6-1.9 13-5.1l-6-4.9C29.1 36.8 26.7 38 24 38c-5.2 0-9.5-3.3-11.1-8l-6.6 5.1C10 41 16.5 45 24 45z"/><path fill="#1976D2" d="M43.6 20.5H42V20H24v8h11.3c-1.1 3.2-3.5 5.7-6.3 7.1l6 4.9C36.4 41.8 44 36 44 25c0-1.3-.1-2.7-.4-4.5z"/></svg>
        Continue with Google
      </button>

      <div class="relative">
        <div class="absolute inset-x-0 top-1/2 border-t border-slate-700"></div>
        <div class="relative flex justify-center">
          <span class="px-2 text-xs text-slate-400 bg-slate-900">or with email</span>
        </div>
      </div>

      <input id="emailInput" type="email" class="w-full bg-slate-950 border border-slate-800 rounded-xl p-2" placeholder="Email"/>
      <input id="passwordInput" type="password" class="w-full bg-slate-950 border border-slate-800 rounded-xl p-2" placeholder="Password (min 6 chars)"/>
      <div class="flex items-center justify-between text-xs">
        <label class="text-slate-400"><input id="showPw" type="checkbox" class="mr-1">Show password</label>
        <button id="forgotBtn" class="text-slate-300 hover:text-white underline">Forgot password?</button>
      </div>
      <button id="authSubmitBtn" class="w-full px-3 py-2 rounded-xl bg-sky-600 hover:bg-sky-500">Sign in with email</button>
      <div class="flex justify-center text-xs text-slate-400">
        <button id="modeToggleBtn" class="underline hover:text-white">New here? Create an account</button>
      </div>
      <div id="authError" class="text-sm text-rose-400 min-h-[1rem]"></div>
    </div>
  </div>
</div>

<!-- Firebase v12 (modular) + app code -->
<script type="module">
  /* ================= Firebase ================= */
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-analytics.js";
  import {
    getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut,
    createUserWithEmailAndPassword, signInWithEmailAndPassword, sendPasswordResetEmail
  } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
  import {
    getFirestore, doc, getDoc, setDoc, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAMyUlfqqOlnt-kHO-C-vB_rzJ-9eudxck",
    authDomain: "chessstudyplanner.firebaseapp.com",
    projectId: "chessstudyplanner",
    storageBucket: "chessstudyplanner.firebasestorage.app",
    messagingSenderId: "73363049381",
    appId: "1:73363049381:web:48da4a1e06b9744fccf64c",
    measurementId: "G-8PE090JLZH"
  };

  const app = initializeApp(firebaseConfig);
  getAnalytics(app); // optional
  const auth = getAuth(app);
  const db   = getFirestore(app);
  const provider = new GoogleAuthProvider();
  provider.setCustomParameters({ prompt: "select_account" });

  /* ============== Local + Cloud state (expanded) ============== */
  const DEFAULTS = {
    A: [
      { id:'aim',   name:'Aimchess warmup', minutes:8, links:[] },
      { id:'tac',   name:'Woodpecker: 8–10 familiar puzzles (60–90s each; write motif if miss)', minutes:9, links:[] },
      { id:'srs',   name:'SRS reviews: previously missed motifs only', minutes:6, links:[] },
      { id:'opn',   name:'Opening study', minutes:12, links:[] },
      { id:'pawn',  name:'Pawn structure notes', minutes:10, links:[] },
    ],
    B: [
      { id:'viz',   name:'Visualization (blindfold)', minutes:5, links:[] },
      { id:'rapid', name:'Rapid game (10+5)', minutes:20, links:[] },
      { id:'anal',  name:'Deep analysis (game review)', minutes:20, links:[] },
    ]
  };

  const DEFAULT_SHELF = [
    { id:'w_lichess',  label:'Lichess',          url:'https://lichess.org',          icon:'img',   img:'https://lichess1.org/assets/logo/lichess-favicon-256.png' },
    { id:'w_analysis', label:'Lichess Analysis', url:'https://lichess.org/analysis', icon:'img',   img:'https://lichess1.org/assets/logo/lichess-favicon-256.png' },
    { id:'w_chessable',label:'Chessable',        url:'https://www.chessable.com',    icon:'emoji', emoji:'📘' }
  ];

  // sessions + shelf
  let sessions = loadSessionsLocal() || structuredClone(DEFAULTS);
  sanitizeSessions(sessions);
  let widgetShelf = loadShelfLocal() || structuredClone(DEFAULT_SHELF);
  let activePreset = localStorage.getItem('preset_v11') || 'BOTH';

  // new: per-section notes (cloud-synced)
  let sectionNotes = {}; // { [sectionId]: string }

  // new: UI prefs (cloud-synced)
  let prefs = {
    floatBtnPos: null,      // {x,y}
    boardWinRC: null,       // {w,h,l,t}
    splitRatio: Number(localStorage.getItem('split_ratio_v2')) || 66,
    outlineCollapsed: false
  };

  // new: timer state (cloud-synced)
  let timerState = {
    sessionStarted:false,
    currentIndex:0,
    secondsLeft:0,
    activePreset
  };

  function loadSessionsLocal(){ try{ return JSON.parse(localStorage.getItem('studySessions_v11')); }catch{ return null; } }
  function saveSessionsLocal(){ localStorage.setItem('studySessions_v11', JSON.stringify(sessions)); }
  function loadShelfLocal(){ try{ return JSON.parse(localStorage.getItem('linkShelf_v1')); }catch{ return null; } }
  function saveShelfLocal(){ localStorage.setItem('linkShelf_v1', JSON.stringify(widgetShelf)); }

  function sanitizeSessions(ss){
    ['A','B','BOTH'].forEach(k=>{
      if(!ss[k]) return;
      ss[k].forEach(s=>{
        if(!('links' in s)) s.links=[];
        if(!('minutes' in s)) s.minutes=5;
        if(!('name' in s)) s.name='Untitled';
        if(!('id' in s)) s.id='S'+Math.random().toString(16).slice(2);
      });
    });
  }

  // cloud helpers
  const cloudStatus = document.getElementById('cloudStatus');
  let currentUser = null;
  const userDocRef = (uid)=> doc(db, 'users', uid, 'apps', 'chess_planner_v1');

  const debounce = (fn,ms=800)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms);} };
  const saveCloudDebounced = debounce(async ()=>{
    if(!currentUser) return;
    try{
      const payload = {
        sessions,
        widgetShelf,
        activePreset,
        notes: sectionNotes,
        prefs,
        timer: timerState,
        updatedAt: serverTimestamp()
      };
      await setDoc(userDocRef(currentUser.uid), payload, { merge:true });
      cloudStatus.textContent = 'Saved to cloud ✓';
    }catch(e){ console.error(e); cloudStatus.textContent='Cloud save failed'; }
  }, 1200);

  function saveSessions(){ saveSessionsLocal(); if(currentUser) saveCloudDebounced(); }
  function saveShelf(){ saveShelfLocal(); if(currentUser) saveCloudDebounced(); }
  function touchCloud(){ if(currentUser) saveCloudDebounced(); }

  /* ================= Presets/Timer/UI ================= */
  const presetSelect = document.getElementById('presetSelect');
  presetSelect.value = activePreset;
  presetSelect.addEventListener('change', ()=>{
    activePreset = presetSelect.value;
    localStorage.setItem('preset_v11', activePreset);
    timerState.activePreset = activePreset;
    if(activePreset==='BOTH' && !sessions.BOTH){
      sessions.BOTH = [...(sessions.A||[]), ...(sessions.B||[])].map(s=>({...s}));
      saveSessions();
    }
    stopTimer();
    sessionStarted=false;
    currentIndex=0;
    secondsLeft = minsToSecs((getSchedule()[0]||{}).minutes||0);
    timerTouch();
    lastDisplayedSec=null;
    isEditingSection=false;
    updateEditUI();
    renderAll();
    updateStartBtnLabel();
  });

  function getSchedule(){
    if(activePreset==='A') return sessions.A || [];
    if(activePreset==='B') return sessions.B || [];
    if(!sessions.BOTH){ sessions.BOTH=[...(sessions.A||[]), ...(sessions.B||[])].map(s=>({...s})); saveSessions(); }
    return sessions.BOTH;
  }
  function getEditableRef(){ return getSchedule(); }

  let running=false, rafId=null, endTimeMs=null, secondsLeft=0, currentIndex=0, lastDisplayedSec=null;
  let sessionStarted=false;
  const clockEl = document.getElementById('clock');
  function minsToSecs(m){ return Math.max(0, Math.round(m*60)); }
  function secsToClock(s){ const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(Math.floor(s%60)).padStart(2,'0'); return `${mm}:${ss}`; }

  function startTimer(){ if(running) return; running=true; syncEnd(); loop(); renderAll(); updateStartBtnLabel(); }
  function stopTimer(){ running=false; if(rafId) cancelAnimationFrame(rafId); rafId=null; updateStartBtnLabel(); timerTouch(); }
  function syncEnd(){ endTimeMs = performance.now() + secondsLeft*1000; }

  function timerTouch(){
    timerState.sessionStarted = sessionStarted;
    timerState.currentIndex = currentIndex;
    timerState.secondsLeft = secondsLeft;
    timerState.activePreset = activePreset;
    touchCloud();
  }

  function loop(){
    if(!running) return;
    const sched=getSchedule(); if(!sched.length){ stopTimer(); return; }
    const remaining = Math.max(0, Math.ceil((endTimeMs - performance.now())/1000));
    if(remaining !== secondsLeft){
      secondsLeft = remaining; lastDisplayedSec=null; renderAll(); timerTouch();
    }
    if(secondsLeft<=0){
      if(currentIndex < sched.length-1){
        currentIndex++;
        secondsLeft=minsToSecs(sched[currentIndex].minutes);
        syncEnd(); beep(); renderAll(); timerTouch();
      } else {
        stopTimer(); beep(); renderAll();
        sessionStarted=false; updateStartBtnLabel(); timerTouch();
        return;
      }
    }
    rafId=requestAnimationFrame(loop);
  }

  const startBtn = document.getElementById('startBtn');
  function updateStartBtnLabel(){
    if(!sessionStarted) startBtn.textContent='Start Study Session';
    else if(running) startBtn.textContent='Pause Session';
    else startBtn.textContent='Resume Session';
  }
  startBtn.onclick=()=>{
    const s=getSchedule(); if(!s.length) return;
    if(!sessionStarted){ currentIndex=0; secondsLeft=minsToSecs(s[0].minutes); sessionStarted=true; timerTouch(); startTimer(); }
    else { if(running) stopTimer(); else startTimer(); }
  };
  document.getElementById('prevBtn').onclick=()=>{ const s=getSchedule(); if(currentIndex>0){ currentIndex--; secondsLeft=minsToSecs(s[currentIndex].minutes); if(running) syncEnd(); lastDisplayedSec=null; renderAll(); timerTouch(); } updateStartBtnLabel(); };
  document.getElementById('nextBtn').onclick=()=>{ const s=getSchedule(); if(currentIndex<s.length-1){ currentIndex++; secondsLeft=minsToSecs(s[currentIndex].minutes); if(running) syncEnd(); timerTouch(); } else stopTimer(); lastDisplayedSec=null; renderAll(); updateStartBtnLabel(); };
  document.getElementById('resetBtn').onclick=()=>{ stopTimer(); sessionStarted=false; currentIndex=0; secondsLeft=minsToSecs((getSchedule()[0]||{}).minutes||0); lastDisplayedSec=null; renderAll(); updateStartBtnLabel(); timerTouch(); };

  function jumpToSection(i){
    const sched=getSchedule(); if(!sched[i]) return;
    currentIndex=i;
    secondsLeft=minsToSecs(sched[i].minutes);
    if(running) syncEnd();
    lastDisplayedSec=null;
    renderAll();
    timerTouch();
  }

  const progressHost=document.getElementById('progressHost'),
        progressFill=document.getElementById('progressFill'),
        progressSegments=document.getElementById('progressSegments'),
        progressTicks=document.getElementById('progressTicks'),
        progressPctEl=document.getElementById('progressPct'),
        legend=document.getElementById('legend'),
        scrubOverlay=document.getElementById('scrubOverlay');

  function scheduleTotalSecs(s){ return s.reduce((a,b)=>a+minsToSecs(b.minutes),0); }
  function elapsedSeconds(sched, idx, secsLeft){
    const past=sched.slice(0,idx).reduce((a,b)=>a+minsToSecs(b.minutes),0);
    const cur=sched[idx]?minsToSecs(sched[idx].minutes)-secsLeft:0;
    return past+cur;
  }
  function buildProgress(){
    const sched=getSchedule(); const total=scheduleTotalSecs(sched)||1;
    progressSegments.innerHTML=''; legend.innerHTML=''; progressTicks.innerHTML='';

    sched.forEach((sec)=>{
      const w=(minsToSecs(sec.minutes)/total)*100;
      const seg=document.createElement('div');
      seg.className='h-full relative bg-slate-900/40';
      seg.style.width=`${w}%`;
      progressSegments.appendChild(seg);
    });

    let cum=0;
    for(let i=1;i<sched.length;i++){
      cum+=minsToSecs(sched[i-1].minutes);
      const pct=(cum/total)*100;
      const tick=document.createElement('div');
      tick.style.position='absolute';
      tick.style.left=pct+'%';
      tick.style.top='0'; tick.style.bottom='0';
      tick.style.width='2px';
      tick.style.background='white';
      tick.style.boxShadow='0 0 10px rgba(255,255,255,.95)';
      progressTicks.appendChild(tick);
    }

    sched.forEach((sec,i)=>{
      const chip=document.createElement('button');
      chip.type='button';
      chip.className='chip';
      chip.dataset.idx=String(i);
      chip.innerHTML = `${escapeHtml(sec.name)} <span class="opacity-80">(${sec.minutes}m)</span>`;
      chip.addEventListener('click', ()=>jumpToSection(i));
      legend.appendChild(chip);
    });
  }
  function updateLegendActive(){
    legend.querySelectorAll('.chip').forEach((el, i)=>{
      el.classList.toggle('chip-active', i===currentIndex);
    });
  }
  function updateProgress(){
    const sched=getSchedule(); const total=scheduleTotalSecs(sched)||1; const elapsed=elapsedSeconds(sched,currentIndex,secondsLeft);
    const pct=Math.min(100,Math.max(0,(elapsed/total)*100));
    progressFill.style.width=pct+'%';
    progressPctEl.textContent=Math.floor(pct)+'%';
    updateLegendActive();
  }
  let scrubbing=false;
  function pctFromEvent(e){ const rect=progressHost.getBoundingClientRect(); const x=(e.clientX ?? (e.touches?.[0]?.clientX ?? 0)) - rect.left; return Math.max(0,Math.min(1,x/rect.width)); }
  function jumpFromPct(p){
    const sched=getSchedule(); const total=scheduleTotalSecs(sched); let target=p*total; let cum=0;
    for(let i=0;i<sched.length;i++){
      const dur=minsToSecs(sched[i].minutes);
      if(target<cum+dur){ currentIndex=i; secondsLeft=Math.max(0,Math.ceil(dur-(target-cum))); if(running) syncEnd(); lastDisplayedSec=null; renderAll(); timerTouch(); return; }
      cum+=dur;
    }
    currentIndex=sched.length-1; secondsLeft=0; stopTimer(); lastDisplayedSec=null; renderAll(); timerTouch();
  }
  scrubOverlay.addEventListener('pointerdown',(e)=>{scrubbing=true; scrubOverlay.setPointerCapture(e.pointerId); jumpFromPct(pctFromEvent(e));});
  scrubOverlay.addEventListener('pointermove',(e)=>{if(scrubbing) jumpFromPct(pctFromEvent(e));});
  scrubOverlay.addEventListener('pointerup',()=>{scrubbing=false;});
  scrubOverlay.addEventListener('pointercancel',()=>{scrubbing=false;});

  const currentTitleEl=document.getElementById('currentTitle');
  const linksDiv=document.getElementById('links');
  const sectionDescEl=document.getElementById('sectionDesc');
  const shelfWrap=document.getElementById('shelfWrap');
  const clearSectionLinksBtn=document.getElementById('clearSectionLinks');
  let isEditingSection=false;

  const editSectionBtn=document.getElementById('editSectionBtn');
  editSectionBtn.addEventListener('click', ()=>{
    isEditingSection = !isEditingSection;
    updateEditUI();
  });

  function updateEditUI(){
    shelfWrap.classList.toggle('hidden', !isEditingSection);
    clearSectionLinksBtn.classList.toggle('hidden', !isEditingSection);
    editSectionBtn.textContent = isEditingSection ? 'Save Changes' : 'Edit Section';
    renderCurrentLinks();
  }

  function currentSectionRef(){ return getSchedule()[currentIndex]; }

  // --- notes persistence (local + cloud) ---
  function loadNoteFor(id){
    return sectionNotes[id] ?? localStorage.getItem('section_desc_'+id) ?? '';
  }
  function saveNoteFor(id, text){
    sectionNotes[id] = text;
    localStorage.setItem('section_desc_'+id, text);
    touchCloud();
  }

  function renderCurrentLinks(){
    const sec=currentSectionRef();
    const arr=sec?.links||[];
    linksDiv.innerHTML = arr.map((w,i)=>`
      <div class="link-card section-link" draggable="true" data-idx="${i}">
        ${w.icon==='img' && w.img ? `<img src="${w.img}" alt="" class="link-icon rounded-[4px] object-cover"/>` : `<span class="link-icon">${w.emoji||'🔗'}</span>`}
        <a class="text-slate-100 truncate max-w-[14rem]" href="${w.url||'#'}" target="_blank" rel="noopener">${escapeHtml(w.label||'Untitled')}</a>
        ${isEditingSection ? `
        <div class="ml-auto flex items-center gap-1">
          <button class="btn-xs" data-act="edit">Edit</button>
          <button class="btn-xs" data-act="remove">Del</button>
        </div>` : ''}
      </div>
    `).join('');

    linksDiv.querySelectorAll('.section-link').forEach(card=>{
      card.addEventListener('dragstart', e=>{
        if(!isEditingSection) { e.preventDefault(); return; }
        const index=Number(card.dataset.idx);
        e.dataTransfer.setData('application/json', JSON.stringify({type:'reorder', index}));
        card.classList.add('drag-ghost');
      });
      card.addEventListener('dragend', ()=> card.classList.remove('drag-ghost'));
    });

    if(isEditingSection){
      linksDiv.querySelectorAll('[data-act="edit"]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const i=Number(btn.closest('[data-idx]').dataset.idx);
          const target=sec.links[i];
          editWidget(target, upd=>{ Object.assign(target, upd); saveSessions(); });
        });
      });
      linksDiv.querySelectorAll('[data-act="remove"]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const i=Number(btn.closest('[data-idx]').dataset.idx);
          sec.links.splice(i,1); saveSessions();
        });
      });
    }
  }
  clearSectionLinksBtn.addEventListener('click', ()=>{
    if(!isEditingSection) return;
    const sec=currentSectionRef(); if(!sec) return;
    if(confirm('Remove all links from this section?')){ sec.links=[]; saveSessions(); }
  });

  const linkShelfDiv=document.getElementById('linkShelf');
  const addWidgetBtn=document.getElementById('addWidgetBtn');
  const resetShelfBtn=document.getElementById('resetShelfBtn');

  function widgetCardHTML(w){
    const icon = (w.icon==='img' && w.img) ? `<img src="${w.img}" alt="" class="link-icon rounded-[4px] object-cover"/>`
                : `<span class="link-icon">${w.emoji||'🔗'}</span>`;
    return `<div class="link-card draggable-shelf" draggable="true" data-wid="${w.id}">
      ${icon}
      <div class="min-w-0">
        <div class="text-slate-100 truncate">${escapeHtml(w.label||'Untitled')}</div>
        <div class="text-xs text-slate-400 truncate">${escapeHtml(w.url||'')}</div>
      </div>
      <div class="ml-auto flex items-center gap-1">
        <button class="btn-xs" data-act="edit">Edit</button>
        <button class="btn-xs" data-act="delete">Del</button>
      </div>
    </div>`;
  }
  function renderShelf(){
    linkShelfDiv.innerHTML = widgetShelf.map(widgetCardHTML).join('');
    linkShelfDiv.querySelectorAll('.draggable-shelf').forEach(card=>{
      card.addEventListener('dragstart', e=>{
        if(!isEditingSection) { e.preventDefault(); return; }
        e.dataTransfer.setData('application/json', JSON.stringify({type:'shelf', id:card.dataset.wid}));
        card.classList.add('drag-ghost');
      });
      card.addEventListener('dragend', ()=> card.classList.remove('drag-ghost'));
    });
    linkShelfDiv.querySelectorAll('[data-act="edit"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        if(!isEditingSection) return;
        const id=btn.closest('[data-wid]').dataset.wid;
        const w=widgetShelf.find(x=>x.id===id);
        editWidget(w, upd=>{ Object.assign(w,upd); saveShelf(); });
      });
    });
    linkShelfDiv.querySelectorAll('[data-act="delete"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        if(!isEditingSection) return;
        const id=btn.closest('[data-wid]').dataset.wid;
        widgetShelf=widgetShelf.filter(w=>w.id!==id);
        saveShelf();
      });
    });
  }
  function editWidget(target, onSave){
    const label = prompt('Title:', target?.label || '') ?? null; if(label===null) return;
    const url   = prompt('URL:', target?.url || '') ?? null; if(url===null) return;
    const type  = prompt('Icon type: emoji / img (leave empty to keep current)', target?.icon || '') || target?.icon || 'emoji';
    let emoji   = target?.emoji || '🔗';
    let img     = target?.img || '';
    if(type==='emoji'){ emoji = prompt('Emoji (or short text):', emoji) || '🔗'; img=''; }
    if(type==='img'){ img = prompt('Image URL:', img) || ''; emoji=''; }
    onSave({label,url,icon:type,emoji,img});
  }
  addWidgetBtn.addEventListener('click', ()=>{
    if(!isEditingSection) return;
    const base={ id:'w_'+Date.now(), label:'New Link', url:'', icon:'emoji', emoji:'🔗', img:'' };
    editWidget(base, upd=>{ widgetShelf.push({...base,...upd}); saveShelf(); });
  });
  resetShelfBtn.addEventListener('click', ()=>{ if(!isEditingSection) return; if(confirm('Reset shelf to defaults?')){ widgetShelf=structuredClone(DEFAULT_SHELF); saveShelf(); }});

  linksDiv.addEventListener('dragover', e=>{ if(!isEditingSection) return; e.preventDefault(); linksDiv.classList.add('drag-over'); });
  linksDiv.addEventListener('dragleave', ()=> linksDiv.classList.remove('drag-over'));
  linksDiv.addEventListener('drop', e=>{
    if(!isEditingSection) return;
    e.preventDefault(); linksDiv.classList.remove('drag-over');
    const data=e.dataTransfer.getData('application/json'); if(!data) return;
    const payload=JSON.parse(data);
    const sec=currentSectionRef(); if(!sec) return;

    if(payload.type==='shelf'){
      const w=widgetShelf.find(x=>x.id===payload.id); if(!w) return;
      sec.links.push({ id:'l_'+Date.now()+Math.random().toString(16).slice(2), label:w.label, url:w.url, icon:w.icon, emoji:w.emoji||'', img:w.img||'' });
      saveSessions();
    } else if(payload.type==='reorder'){
      const from=payload.index;
      const cards=[...linksDiv.querySelectorAll('.section-link')];
      let to=cards.length;
      for(let i=0;i<cards.length;i++){
        const r=cards[i].getBoundingClientRect();
        if(e.clientY < r.top + r.height/2){ to=i; break; }
      }
      if(from===to || from==null || to==null) return;
      const [m]=sec.links.splice(from,1);
      sec.links.splice(to,0,m);
      saveSessions();
    }
  });

  /* ============== Outline (inline edit, bug-fixed) ============== */
  const outline=document.getElementById('outline');
  const totalMins=document.getElementById('totalMins');

  // Track whether any row is in edit mode to suppress jump clicks
  let editingOutlineId = null;

  const toMinutes = (value, unit)=>{
    const v = Number(value)||0;
    if(unit==='seconds') return v/60;
    if(unit==='hours')   return v*60;
    return v; // minutes
  };

  function renderOutline(){
    const sched=getSchedule();
    outline.innerHTML = sched.map((s,i)=>`
      <li class="outline-row ${i===currentIndex?'outline-active':''}" data-id="${s.id}" draggable="${editingOutlineId? 'false' : 'true'}">
        <div class="flex items-center gap-3">
          <button class="text-left min-w-0 flex-1 truncate text-sm focus:outline-none">${escapeHtml(s.name)}</button>
          <div class="flex items-center gap-2 shrink-0">
            <span class="text-xs text-slate-300 w-16 text-right">${Number(s.minutes)}m</span>
            <button class="btn-xs" data-act="edit">Edit</button>
          </div>
        </div>
      </li>
    `).join('');

    // click to jump (disabled while editing)
    outline.querySelectorAll('li[data-id]').forEach((li, idx)=>{
      li.addEventListener('click', (e)=>{
        if(editingOutlineId) return;
        if(e.target.closest('[data-act]')) return;
        jumpToSection(idx);
      });
    });

    // inline edit
    outline.querySelectorAll('[data-act="edit"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const li = btn.closest('li[data-id]');
        const id = li.dataset.id;
        const ref=getEditableRef();
        const idx=ref.findIndex(x=>x.id===id);
        if(idx<0) return;
        const cur=ref[idx];
        editingOutlineId = id;

        // build compact inline editor in-place
        li.innerHTML = `
          <div class="outline-edit">
            <input id="edtTitle" class="inline-field text-sm flex-1 min-w-0" type="text" value="${escapeHtml(cur.name)}" />
            <input id="edtValue" class="inline-field inline-number text-sm" type="number" step="0.1" min="0.01" value="${(+cur.minutes).toFixed(2).replace(/\.00$/,'')}" />
            <select id="edtUnit" class="inline-field inline-select text-sm">
              <option value="minutes" selected>min</option>
              <option value="seconds">sec</option>
              <option value="hours">hr</option>
            </select>
            <button class="btn-xxs" id="edtSave">Save</button>
            <button class="btn-xxs" id="edtCancel">Cancel</button>
          </div>
        `;

        // prevent clicks inside editor from bubbling to li (fixes minimize bug)
        li.querySelector('.outline-edit').addEventListener('click', ev=>ev.stopPropagation());

        const edtTitle = li.querySelector('#edtTitle');
        const edtValue = li.querySelector('#edtValue');
        const edtUnit  = li.querySelector('#edtUnit');
        const saveBtn  = li.querySelector('#edtSave');
        const cancelBtn= li.querySelector('#edtCancel');

        const cancel = ()=>{ editingOutlineId=null; renderOutline(); };
        cancelBtn.addEventListener('click', cancel);
        li.addEventListener('keydown', (e)=>{ if(e.key==='Escape') cancel(); });

        const save = ()=>{
          const newTitle = edtTitle.value.trim() || cur.name;
          const mins = Math.max(0.01, toMinutes(edtValue.value, edtUnit.value));
          cur.name = newTitle;
          cur.minutes = mins;
          saveSessions();
          if(getSchedule()[currentIndex]?.id===cur.id){
            secondsLeft = Math.min(secondsLeft, minsToSecs(cur.minutes));
            if(running) syncEnd();
            timerTouch();
          }
          editingOutlineId=null;
          renderOutline();
          buildProgress(); updateProgress(); renderCurrent();
        };
        saveBtn.addEventListener('click', save);
        li.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && (e.metaKey||e.ctrlKey)) save(); });
        edtTitle.focus();
      });
    });

    makeOutlineDnD(outline, getEditableRef());
    totalMins.textContent=`Total: ${Math.round(scheduleTotalSecs(getSchedule())/60)} minutes`;
  }

  function makeOutlineDnD(listEl, backingArray){
    let draggingEl=null;
    let startedOnEdit=false;

    listEl.querySelectorAll('li[draggable="true"]').forEach(li=>{
      li.addEventListener('pointerdown', (e)=>{ startedOnEdit = !!e.target.closest('[data-act]'); });
      li.addEventListener('dragstart', (e)=>{
        if(startedOnEdit || editingOutlineId){ e.preventDefault(); startedOnEdit=false; return; }
        draggingEl = li;
        li.classList.add('drag-ghost');
        e.dataTransfer.effectAllowed = 'move';
        try { e.dataTransfer.setData('text/plain', li.dataset.id); } catch {}
      });
      li.addEventListener('dragend', ()=>{
        if(!draggingEl) return;
        draggingEl.classList.remove('drag-ghost');
        const currentId = getSchedule()[currentIndex]?.id;
        const ids = [...listEl.querySelectorAll('li[data-id]')].map(n=>n.dataset.id);
        const map = Object.fromEntries(backingArray.map(x=>[x.id,x]));
        backingArray.splice(0, backingArray.length, ...ids.map(id=>map[id]).filter(Boolean));
        saveSessions();
        const newIndex = getSchedule().findIndex(s=>s.id===currentId);
        if(newIndex>=0) currentIndex=newIndex;
        renderAll();
        draggingEl=null;
      });
    });

    listEl.addEventListener('dragover', (e)=>{
      if(!draggingEl) return;
      e.preventDefault();
      const after = getDragAfterElement(listEl, e.clientY);
      if(after==null) listEl.appendChild(draggingEl);
      else if(after !== draggingEl) listEl.insertBefore(draggingEl, after);
    });
    listEl.addEventListener('drop', (e)=>{ e.preventDefault(); });
  }
  function getDragAfterElement(container, y){
    const els=[...container.querySelectorAll('li[data-id]:not(.drag-ghost)')];
    return els.reduce((closest,child)=>{
      const box=child.getBoundingClientRect();
      const offset=y - (box.top + box.height/2);
      if(offset<0 && offset>closest.offset) return {offset, element:child};
      else return closest;
    }, {offset: Number.NEGATIVE_INFINITY, element:null}).element;
  }

  document.getElementById('addOutlineItem').addEventListener('click', ()=>{
    const ref=getEditableRef();
    const title = prompt('New section title:','New section');
    if(title===null) return;
    const minsRaw = prompt('Minutes:','5');
    if(minsRaw===null) return;
    const mins = Math.max(0.01, Number(minsRaw)||5);
    ref.push({ id:'S'+Date.now(), name:title.trim()||'New section', minutes:mins, links:[] });
    saveSessions(); renderAll();
  });

  /* ================= Splitter & board with cloud prefs ================= */
  const split = document.getElementById('split');
  const splitHandle = document.getElementById('splitHandle');
  const showOutlineBtn = document.getElementById('showOutlineBtn');
  const collapseOutlineBtn = document.getElementById('collapseOutlineBtn');

  function applySplit(pct){
    pct=Math.max(40,Math.min(85,pct));
    split.style.setProperty('--leftRatio', pct + '%');
    localStorage.setItem('split_ratio_v2', String(pct));
    prefs.splitRatio = pct;
    touchCloud();
  }
  applySplit(prefs.splitRatio);

  let resizing=false;
  splitHandle.addEventListener('pointerdown', (e)=>{ if(split.classList.contains('collapsed')) return; resizing=true; splitHandle.setPointerCapture(e.pointerId); });
  splitHandle.addEventListener('pointermove', (e)=>{ if(!resizing) return; const rect=split.getBoundingClientRect(); const x=Math.max(rect.left+120, Math.min(e.clientX, rect.right-260)); const pct=((x-rect.left)/rect.width)*100; applySplit(pct); });
  splitHandle.addEventListener('pointerup', ()=>{ resizing=false; });

  function setOutlineCollapsed(collapsed){
    split.classList.toggle('collapsed', collapsed);
    showOutlineBtn.classList.toggle('hidden', !collapsed);
    prefs.outlineCollapsed = collapsed;
    touchCloud();
  }

  collapseOutlineBtn.addEventListener('click', ()=> setOutlineCollapsed(true));
  showOutlineBtn.addEventListener('click', ()=> setOutlineCollapsed(false));

  const floatBtn = document.getElementById('floatBtn');
  const boardWin = document.getElementById('boardWin');
  const boardHeader = document.getElementById('boardHeader');
  const boardIframe = document.getElementById('boardIframe');
  const fenBar = document.getElementById('fenBar');
  const applyFenBtn = document.getElementById('applyFen');
  const openViewerBtn = document.getElementById('openViewer');
  const popOut = document.getElementById('popOut');
  const minimizeBoard = document.getElementById('minimizeBoard');
  const closeBoard = document.getElementById('closeBoard');

  function setIframeToAnalysisFen(fen){
    const url = `https://lichess.org/embed/analysis?fen=${encodeURIComponent(fen)}&theme=auto&bg=auto`;
    boardIframe.src = url; popOut.href = url;
  }
  function setIframeToGame(gameIdOrUrl){
    const id = (gameIdOrUrl||'').split('/').pop().split('#')[0].split('?')[0];
    const url = `https://lichess.org/embed/${id}#0?theme=auto&bg=auto`;
    boardIframe.src = url; popOut.href = url;
  }
  function showBoard(){ boardWin.classList.remove('minimized'); minimizeBoard.textContent='Minimize'; minimizeBoard.setAttribute('aria-expanded','true'); boardWin.style.display='block'; }
  function hideBoard(){ boardWin.style.display='none'; }
  floatBtn.addEventListener('click', ()=> showBoard());
  minimizeBoard.addEventListener('click', (e)=>{
    e.stopPropagation();
    const isMin=boardWin.classList.toggle('minimized');
    minimizeBoard.textContent=isMin?'Restore':'Minimize';
    minimizeBoard.setAttribute('aria-expanded', String(!isMin));
  });
  closeBoard.addEventListener('click', (e)=>{
    e.stopPropagation();
    try{ boardIframe.src='about:blank'; popOut.href='#'; }catch{}
    boardWin.classList.remove('minimized'); minimizeBoard.textContent='Minimize'; minimizeBoard.setAttribute('aria-expanded','true'); hideBoard();
  });

  // Floating button (position persisted to cloud)
  (function(){
    // apply from local storage first
    let pos=JSON.parse(localStorage.getItem('float_btn_pos_v1')||'null')||{x:null,y:null};
    if(pos.x!=null&&pos.y!=null){ floatBtn.style.left=pos.x+'px'; floatBtn.style.top=pos.y+'px'; floatBtn.style.right='auto'; floatBtn.style.bottom='auto'; }
    if(prefs.floatBtnPos){ floatBtn.style.left=prefs.floatBtnPos.x; floatBtn.style.top=prefs.floatBtnPos.y; floatBtn.style.right='auto'; floatBtn.style.bottom='auto'; }
    let dragging=false, offX=0, offY=0;
    floatBtn.addEventListener('pointerdown', e=>{ dragging=true; floatBtn.setPointerCapture(e.pointerId); const r=floatBtn.getBoundingClientRect(); offX=e.clientX-r.left; offY=e.clientY-r.top; });
    floatBtn.addEventListener('pointermove', e=>{ if(!dragging) return; floatBtn.style.left=(e.clientX-offX)+'px'; floatBtn.style.top=(e.clientY-offY)+'px'; floatBtn.style.right='auto'; floatBtn.style.bottom='auto'; });
    function end(){
      if(!dragging) return; dragging=false; const r=floatBtn.getBoundingClientRect();
      const p={x:r.left+'px',y:r.top+'px'};
      localStorage.setItem('float_btn_pos_v1', JSON.stringify({x:r.left,y:r.top}));
      prefs.floatBtnPos=p; touchCloud();
    }
    floatBtn.addEventListener('pointerup', end); floatBtn.addEventListener('pointercancel', end);
  })();

  // Board window RC (persist to cloud)
  (function(){
    const ls=JSON.parse(localStorage.getItem('board_win_rc_v1')||'null');
    const saved= prefs.boardWinRC || ls;
    if(saved){ boardWin.style.width=saved.w; boardWin.style.height=saved.h; boardWin.style.left=saved.l; boardWin.style.top=saved.t; boardWin.style.right='auto'; boardWin.style.bottom='auto'; }
    let dragging=false, dx=0, dy=0;
    boardHeader.addEventListener('pointerdown', e=>{
      if (e.target.closest('button, a, input, select, textarea')) return;
      dragging=true; boardHeader.setPointerCapture(e.pointerId);
      const r=boardWin.getBoundingClientRect(); dx=e.clientX-r.left; dy=e.clientY-r.top;
    });
    boardHeader.addEventListener('pointermove', e=>{ if(!dragging) return; const ww=innerWidth, wh=innerHeight; const nx=Math.min(ww-40,Math.max(10,e.clientX-dx)); const ny=Math.min(wh-40,Math.max(10,e.clientY-dy)); boardWin.style.left=nx+'px'; boardWin.style.top=ny+'px'; boardWin.style.right='auto'; boardWin.style.bottom='auto'; });
    function endDrag(){ if(!dragging) return; dragging=false; const r=boardWin.getBoundingClientRect(); const rc={w:r.width+'px',h:r.height+'px',l:r.left+'px',t:r.top+'px'}; localStorage.setItem('board_win_rc_v1', JSON.stringify(rc)); prefs.boardWinRC=rc; touchCloud(); }
    boardHeader.addEventListener('pointerup', endDrag); boardHeader.addEventListener('pointercancel', endDrag);

    function startResize(handle, mode){
      return function(e){
        e.preventDefault(); handle.setPointerCapture(e.pointerId);
        const start={x:e.clientX,y:e.clientY}; const rect=boardWin.getBoundingClientRect();
        function mm(ev){
          const dx=ev.clientX-start.x, dy=ev.clientY-start.y;
          let w=rect.width, h=rect.height;
          if(mode.includes('ew')) w=Math.max(380, rect.width+dx);
          if(mode.includes('ns')) h=Math.max(320, rect.height+dy);
          if(mode.includes('nwse')){ w=Math.max(380, rect.width+dx); h=Math.max(320, rect.height+dy); }
          boardWin.style.width=w+'px'; boardWin.style.height=h+'px';
        }
        function end(){
          try{ handle.releasePointerCapture(e.pointerId);}catch{}
          document.removeEventListener('pointermove',mm);
          document.removeEventListener('pointerup',end);
          const r=boardWin.getBoundingClientRect();
          const rc={w:r.width+'px',h:r.height+'px',l:r.left+'px',t:r.top+'px'};
          localStorage.setItem('board_win_rc_v1', JSON.stringify(rc));
          prefs.boardWinRC=rc; touchCloud();
        }
        document.addEventListener('pointermove',mm);
        document.addEventListener('pointerup',end);
      }
    }
    document.querySelector('.resizer.e').addEventListener('pointerdown', startResize(document.querySelector('.resizer.e'),'ew'));
    document.querySelector('.resizer.s').addEventListener('pointerdown', startResize(document.querySelector('.resizer.s'),'ns'));
    document.querySelector('.resizer.se').addEventListener('pointerdown', startResize(document.querySelector('.resizer.se'),'nwse'));
  })();

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
  function beep(){ try{ const AC=window.AudioContext||window.webkitAudioContext; const ctx=new AC(); const now=ctx.currentTime; const o1=ctx.createOscillator(), g1=ctx.createGain(); o1.type='sine'; o1.frequency.value=880; o1.connect(g1); g1.connect(ctx.destination); g1.gain.setValueAtTime(.0001,now); g1.gain.exponentialRampToValueAtTime(.18,now+.01); o1.start(now); o1.stop(now+.12); const o2=ctx.createOscillator(), g2=ctx.createGain(); o2.type='sine'; o2.frequency.value=1318.5; o2.connect(g2); g2.connect(ctx.destination); g2.gain.setValueAtTime(.0001,now+.13); g2.gain.exponentialRampToValueAtTime(.16,now+.15); o2.start(now+.13); o2.stop(now+.28);}catch{} }

  function renderCurrent(){
    const sched=getSchedule(); const cur=sched[currentIndex];
    currentTitleEl.textContent=cur?cur.name:'—';
    if(secondsLeft!==lastDisplayedSec){ clockEl.textContent=secsToClock(secondsLeft); lastDisplayedSec=secondsLeft; }

    if(cur){
      const key = cur.id;
      sectionDescEl.value = loadNoteFor(key);
      sectionDescEl.oninput = ()=> saveNoteFor(key, sectionDescEl.value);
    }else{
      sectionDescEl.value = '';
      sectionDescEl.oninput = null;
    }

    renderCurrentLinks();
  }
  function renderAll(){ buildProgress(); updateProgress(); updateLegendActive(); renderCurrent(); renderShelf(); renderOutline(); }

  // Initial render & default timer state
  let secondsInit = minsToSecs((getSchedule()[0]||{}).minutes||0);
  secondsLeft = secondsInit;
  timerState.secondsLeft = secondsLeft;
  timerState.currentIndex = currentIndex;
  renderAll();
  if(!loadSessionsLocal()) saveSessionsLocal();
  updateStartBtnLabel();
  updateEditUI();

  /* =================== Auth UI =================== */
  const authOpenBtn = document.getElementById('authOpenBtn');
  const userBadge  = document.getElementById('userBadge');
  const userEmail  = document.getElementById('userEmail');
  const signOutBtn = document.getElementById('signOutBtn');

  const authModal = document.getElementById('authModal');
  const authModalTitle = document.getElementById('authModalTitle');
  const closeAuthModal = document.getElementById('closeAuthModal');
  const googleAuthBtn = document.getElementById('googleAuthBtn');
  const emailInput = document.getElementById('emailInput');
  const passwordInput = document.getElementById('passwordInput');
  const showPw = document.getElementById('showPw');
  const forgotBtn = document.getElementById('forgotBtn');
  const authSubmitBtn = document.getElementById('authSubmitBtn');
  const modeToggleBtn = document.getElementById('modeToggleBtn');
  const authError = document.getElementById('authError');

  let authMode = 'signin'; // or 'signup'

  function setAuthUI(signedIn, email=''){
    if(signedIn){
      authOpenBtn.classList.add('hidden');
      userBadge.classList.remove('hidden');
      userEmail.textContent = email;
      cloudStatus.textContent = 'Cloud sync on';
    }else{
      userBadge.classList.add('hidden');
      authOpenBtn.classList.remove('hidden');
      cloudStatus.textContent = 'Local mode';
    }
  }

  function openAuthModal(mode='signin'){
    authMode = mode;
    authModalTitle.textContent = mode === 'signin' ? 'Sign in' : 'Create your account';
    authSubmitBtn.textContent = mode === 'signin' ? 'Sign in with email' : 'Sign up with email';
    modeToggleBtn.textContent = mode === 'signin' ? 'New here? Create an account' : 'Already have an account? Sign in instead';
    forgotBtn.classList.toggle('hidden', mode !== 'signin');
    emailInput.value = '';
    passwordInput.value = '';
    authError.textContent = '';
    authModal.classList.remove('hidden');
    authModal.classList.add('flex');
    emailInput.focus();
  }
  const closeModal = ()=>{ authModal.classList.add('hidden'); authModal.classList.remove('flex'); };

  authOpenBtn.addEventListener('click', ()=> openAuthModal('signin'));
  modeToggleBtn.addEventListener('click', ()=> openAuthModal(authMode==='signin'?'signup':'signin'));
  closeAuthModal.addEventListener('click', closeModal);
  authModal.addEventListener('click', (e)=>{ if(e.target === authModal) closeModal(); });

  showPw.addEventListener('change', ()=>{ passwordInput.type = showPw.checked ? 'text' : 'password'; });

  googleAuthBtn.addEventListener('click', async ()=>{
    authError.textContent = '';
    try{
      await signInWithPopup(auth, provider);
      closeModal();
    }catch(e){
      if(e && e.code === 'auth/unauthorized-domain'){
        authError.textContent = 'This domain is not authorized. In Firebase Console → Authentication → Settings → Authorized domains, add your deployed domain (e.g., loxtyrell03.github.io), then refresh.';
      }else{
        authError.textContent = e.message || 'Google sign-in failed';
      }
    }
  });

  async function handleEmailSubmit(){
    authError.textContent = '';
    const email = emailInput.value.trim();
    const pw = passwordInput.value;
    if(!email || !pw){ authError.textContent = 'Please enter email and password.'; return; }
    try{
      if(authMode === 'signin'){
        await signInWithEmailAndPassword(auth, email, pw);
      }else{
        await createUserWithEmailAndPassword(auth, email, pw);
      }
      closeModal();
    }catch(e){
      authError.textContent = e.message || 'Authentication failed';
    }
  }
  authSubmitBtn.addEventListener('click', handleEmailSubmit);
  emailInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') handleEmailSubmit(); });
  passwordInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') handleEmailSubmit(); });

  forgotBtn.addEventListener('click', async ()=>{
    const email = emailInput.value.trim();
    if(!email){ authError.textContent = 'Enter your email first.'; return; }
    try{
      await sendPasswordResetEmail(auth, email);
      authError.textContent = 'Password reset email sent.';
    }catch(e){
      authError.textContent = e.message || 'Could not send reset email.';
    }
  });

  signOutBtn.addEventListener('click', ()=> signOut(auth));

  onAuthStateChanged(auth, async (user)=>{
    currentUser = user || null;
    if(!user){ setAuthUI(false); return; }
    setAuthUI(true, user.email || '');
    try{
      const ref = userDocRef(user.uid);
      const snap = await getDoc(ref);
      if(snap.exists()){
        const data = snap.data() || {};
        if(data.sessions){ sessions = data.sessions; sanitizeSessions(sessions); }
        if(data.widgetShelf){ widgetShelf = data.widgetShelf; }
        if(typeof data.activePreset==='string'){ activePreset = data.activePreset; presetSelect.value = activePreset; }
        if(data.notes){ sectionNotes = data.notes || {}; }
        if(data.prefs){
          prefs = Object.assign(prefs, data.prefs);
          if(prefs.splitRatio) applySplit(prefs.splitRatio);
          if(prefs.outlineCollapsed) setOutlineCollapsed(true);
          if(prefs.floatBtnPos){
            floatBtn.style.left=prefs.floatBtnPos.x; floatBtn.style.top=prefs.floatBtnPos.y; floatBtn.style.right='auto'; floatBtn.style.bottom='auto';
          }
          if(prefs.boardWinRC){
            const rc=prefs.boardWinRC;
            boardWin.style.width=rc.w; boardWin.style.height=rc.h; boardWin.style.left=rc.l; boardWin.style.top=rc.t; boardWin.style.right='auto'; boardWin.style.bottom='auto';
          }
        }
        if(data.timer){
          timerState = Object.assign(timerState, data.timer);
          activePreset = timerState.activePreset || activePreset; presetSelect.value = activePreset;
          // restore timer vars (do not auto-run)
          sessionStarted = !!timerState.sessionStarted;
          currentIndex = Math.min(Math.max(0, timerState.currentIndex|0), Math.max(0, getSchedule().length-1));
          const cur = getSchedule()[currentIndex];
          const maxSecs = cur ? minsToSecs(cur.minutes) : 0;
          secondsLeft = Math.min(Math.max(0, timerState.secondsLeft|0), maxSecs);
          updateStartBtnLabel();
        }
        saveSessionsLocal(); saveShelfLocal();
        renderAll();
      }else{
        await setDoc(ref, {
          sessions, widgetShelf, activePreset,
          notes: sectionNotes, prefs, timer: timerState,
          createdAt: serverTimestamp(), updatedAt: serverTimestamp()
        });
      }
      cloudStatus.textContent = 'Cloud sync on';
    }catch(e){
      console.error(e);
      cloudStatus.textContent = 'Cloud load failed';
    }
  });
</script>
</body>
</html>
