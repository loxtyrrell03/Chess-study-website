<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Skillflow — Plan sessions. Build momentum.</title>
  <meta name="color-scheme" content="light dark"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="./styles.css"/>

  <!-- Page-specific quick fixes/overrides -->
  <style id="index-overrides">
    /* Stronger progress fill + layering */
    #progressSegments{ z-index:0 !important; }
    #progressFill{
      z-index:2 !important;
      background:linear-gradient(90deg,var(--accent-100),color-mix(in srgb,var(--accent) 55%, transparent)) !important;
      border-right:2px solid var(--accent-600) !important;
    }
    #progressTicks{ z-index:3 !important; }
    #scrubOverlay{ z-index:4 !important; }

    /* Focus overlay mirroring */
    #focusProgressSegments{ z-index:0 !important; }
    #focusProgressFill{
      z-index:2 !important;
      background:linear-gradient(90deg,var(--accent-100),color-mix(in srgb,var(--accent) 55%, transparent)) !important;
      border-right:2px solid var(--accent-600) !important;
    }
    #focusProgressTicks{ z-index:3 !important; }
    #focusScrubOverlay{ z-index:4 !important; }

    /* Live reorder: hide the original row so there is NO ghost copy */
    .outline-row.dragging{ display:none !important; }

    /* Tight, consistent inline number/select heights */
    :root { --sf-editor-field-h: 44px; }
    #editMinsInline, #edtValue,
    #editUnitInline, #edtUnit{
      height: var(--sf-editor-field-h) !important;
      box-sizing: border-box;
      font-size: 0.95rem;
      line-height: normal;
      padding: 8px 12px 10px 12px;
      border-radius: .75rem;
      vertical-align: middle;
    }
    #editMinsInline, #edtValue { padding-right:.75rem; }
    #editUnitInline, #edtUnit  { padding-right:2rem; appearance:none; background-repeat:no-repeat; background-position:right .6rem center; }
  </style>
</head>

<body class="min-h-screen">
<div class="max-w-7xl mx-auto px-5 py-6">

  <!-- Header -->
  <header class="mb-4 flex flex-col gap-1 sm:flex-row sm:items-center sm:justify-between">
    <div>
      <h1 class="text-3xl sm:text-4xl font-extrabold tracking-tight">Skillflow</h1>
      <p class="text-sm muted -mt-1">Structure your training. Master any skill.</p>
    </div>
    <div class="flex flex-wrap items-center gap-2">
      <button id="settingsBtn" class="px-3 py-2 rounded-xl border border-[var(--border)]" title="Customize UI">⚙️ Settings</button>

      <div id="authArea" class="flex items-center gap-2">
        <button id="authOpenBtn" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white">Sign in / Sign up</button>
        <div id="userBadge" class="hidden items-center gap-2">
          <span id="userEmail" class="text-sm muted"></span>
          <button id="signOutBtn" class="px-3 py-2 rounded-xl bg-rose-600 hover:bg-rose-500 text-white">Sign out</button>
        </div>
      </div>

      <span id="cloudStatus" class="text-xs muted">Local mode</span>
    </div>
  </header>

  <!-- Tabs -->
  <nav class="mb-6">
    <div class="tabs-bar overflow-x-auto">
      <button class="tab-link active" data-tab="overviewTab">Overview</button>
      <div class="tab-sep"></div>
      <button class="tab-link" data-tab="homeTab">Planner</button>
      <div class="tab-sep"></div>
      <button class="tab-link" data-tab="savedTab">Saved Outlines</button>
      <div class="tab-sep"></div>
      <button class="tab-link" data-tab="helpTab">How to use</button>
    </div>
  </nav>

  <!-- OVERVIEW / Landing -->
  <section id="overviewTab">
    <div class="card p-6 md:p-10 relative overflow-hidden">
      <div class="absolute -inset-1 bg-[radial-gradient(ellipse_at_top_right,rgba(14,165,233,.25),transparent_40%),radial-gradient(ellipse_at_bottom_left,rgba(16,185,129,.25),transparent_40%)] pointer-events-none"></div>
      <div class="relative z-10">
        <h2 class="text-3xl md:text-5xl font-extrabold mb-2">Plan one focused session.<br/>Build momentum.</h2>
        <p class="text-lg text-slate-600 max-w-2xl">
          Skillflow breaks a work block into mini‑goals with a live progress bar and instant feedback,
          so you avoid drift and finish strong.
        </p>
        <div class="mt-4 flex gap-2">
          <button class="px-4 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 text-white shadow-sm" data-tab-jump="homeTab">Open Planner</button>
          <button class="px-4 py-2 rounded-xl border border-[var(--border)]" data-tab-jump="savedTab">Browse outlines</button>
        </div>
      </div>

      <!-- Animated mini-demo -->
      <div class="mt-8 grid md:grid-cols-2 gap-6 relative z-10">
        <div class="card p-5">
          <div class="flex items-center justify-between mb-1">
            <div class="block-sub">Live demo</div>
            <div id="demoPct" class="text-xs muted">0%</div>
          </div>
          <div class="relative w-full h-6 rounded-2xl overflow-hidden card">
            <div id="demoFill" class="absolute left-0 top-0 bottom-0" style="width:0%;background:linear-gradient(90deg,var(--accent-100),color-mix(in srgb,var(--accent) 55%, transparent));border-right:2px solid var(--accent-600)"></div>
          </div>
          <div class="mt-3 flex gap-2">
            <button id="demoPlay" class="btn-xs">▶ Play demo</button>
            <button id="demoReset" class="btn-xs">Reset</button>
          </div>
        </div>
        <ul class="grid gap-3">
          <li class="section-collapsed"><span><b>Single-session focus</b></span><span>Plan once, then flow.</span></li>
          <li class="section-collapsed"><span><b>Instant section jumps</b></span><span>Tap chips or the outline.</span></li>
          <li class="section-collapsed"><span><b>Links & notes</b></span><span>Keep everything at hand.</span></li>
          <li class="section-collapsed"><span><b>Cloud sync</b></span><span>Pick up where you left off.</span></li>
        </ul>
      </div>
    </div>
  </section>

  <!-- PLANNER / Home -->
  <section id="homeTab" class="hidden">
    <!-- Progress -->
    <section class="mb-4">
      <div class="flex items-center justify-between mb-1">
        <div class="block-sub">Progress — click to jump</div>
        <div class="flex items-center gap-3">
          <div id="progressTotal" class="text-xs muted">Total: 0m</div>
          <div id="progressPct" class="text-xs muted">0%</div>
        </div>
      </div>
      <div id="progressHost" class="relative w-full h-6 rounded-2xl overflow-hidden card">
        <div id="progressFill" class="absolute left-0 top-0 bottom-0 transition-[width]" style="width:0%"></div>
        <div id="progressSegments" class="absolute inset-0 flex"></div>
        <div id="progressTicks" class="absolute inset-0 pointer-events-none"></div>
        <div id="scrubOverlay" class="absolute inset-0 cursor-pointer"></div>
      </div>
      <div id="legend" class="mt-2 flex flex-wrap gap-2 text-sm"></div>
    </section>

    <!-- Controls -->
    <section class="flex flex-wrap items-center gap-3 mb-3">
      <button id="startBtn" class="px-4 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 text-white shadow-sm">Start Study Session</button>

      <!-- One-time gate shown right when a section completes -->
      <button id="readyNextBtn" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white shadow-sm hidden">
        I’m ready — start next ▶
      </button>

      <button id="prevBtn" class="px-3 py-2 rounded-xl border border-[var(--border)]">◀ Prev</button>
      <button id="nextBtn" class="px-3 py-2 rounded-xl border border-[var(--border)]">Next ▶</button>

      <!-- Focus Mode trigger -->
      <button id="focusModeBtn" class="px-3 py-2 rounded-xl border border-[var(--border)]">Focus Mode</button>

      <button id="resetBtn" class="ml-auto px-3 py-2 rounded-xl border border-[var(--border)]">Reset</button>
      <button id="showOutlineBtn" class="px-3 py-2 rounded-xl border border-[var(--border)] hidden">Show Outline ▸</button>
    </section>

    <div id="split">
      <!-- LEFT -->
      <section id="leftPane">
        <div class="card p-6 section-card">
          <div class="flex items-center justify-between gap-3 border-b border-[var(--border)] pb-3">
            <div class="min-w-0 flex items-center gap-3">
              <h2 id="currentTitle" class="text-2xl font-extrabold truncate">—</h2>
              <span id="currentDurDisp" class="text-sm muted whitespace-nowrap">0m</span>
              <input id="editTitleInline" class="input text-2xl font-extrabold hidden align-middle shrink-0" placeholder="Section title" />
              <div id="editDurInline" class="hidden flex items-stretch gap-1 flex-nowrap whitespace-nowrap">
                <input id="editMinsInline" class="input h-9 w-24 text-sm" type="number" min="0.01" step="0.1" placeholder="Min"/>
                <select id="editUnitInline" class="input h-9 w-24 text-sm">
                  <option value="minutes" selected>min</option>
                  <option value="seconds">sec</option>
                  <option value="hours">hr</option>
                </select>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button id="editSectionBtn" class="px-3 py-2 rounded-xl border border-[var(--border)] text-sm">Edit Section</button>
              <div id="clock" class="clock-badge text-2xl tabular-nums">00:00</div>
            </div>
          </div>

          <!-- Shelf -->
          <div id="shelfWrap" class="mt-4 hidden">
            <div class="flex items-center justify-between">
              <h3 class="block-title">Widget shelf</h3>
              <div class="flex items-center gap-2">
                <button id="addWidgetBtn" class="btn-xs">+ New Widget</button>
                <button id="resetShelfBtn" class="btn-xs">Reset Shelf</button>
              </div>
            </div>
            <div id="linkShelf" class="mt-2 editor-shelf"></div>
            <div class="text-xs muted mt-1">Drag from shelf → links below. Click any item to edit.</div>
          </div>

          <!-- Links -->
          <div id="linksWrap" class="mt-4">
            <div class="flex items-center justify-between">
              <h3 class="block-title">Links</h3>
              <button id="clearSectionLinks" class="btn-xs hidden">Clear</button>
            </div>
            <div id="links" class="section-links-bar mt-2"></div>
          </div>

          <!-- Description -->
          <div class="mt-4">
            <label class="block-title">Description</label>
            <textarea id="sectionDesc" class="w-full mt-1 input text-sm" placeholder="Add notes, mini-checklist, links…"></textarea>
          </div>
        </div>
      </section>

      <!-- HANDLE -->
      <div id="splitHandle"></div>

      <!-- RIGHT -->
      <aside id="rightPane">
        <div class="card p-4 h-full flex flex-col">

          <!-- Quick load -->
          <div id="homeSavedRow" class="mb-3">
            <div class="flex items-center justify-between">
              <h4 class="block-title">Saved Outlines</h4>
              <button id="manageOutlinesLink" class="text-xs underline" data-tab-jump="savedTab">Manage</button>
            </div>
            <div id="homeSavedScroller" class="mt-2 flex gap-2 overflow-x-auto p-2 rounded-xl border border-[var(--border)] bg-[var(--panel)]"></div>
          </div>

          <div class="flex items-center justify-between">
            <h3 class="block-title">Session outline</h3>
            <button id="collapseOutlineBtn" class="text-xs px-2 py-1 rounded-md border border-[var(--border)]">▾ Hide</button>
          </div>

          <ul id="outline" class="mt-3 flex-1 overflow-auto"></ul>

          <!-- Inline Add -->
          <div id="inlineAddRow" class="mt-2 hidden">
            <div class="flex flex-wrap items-center gap-2">
              <input id="addTitleInput" class="input flex-1" placeholder="Section title"/>
              <input id="addMinsInput" class="input w-28" type="number" min="0.25" step="0.25" placeholder="Minutes"/>
              <button id="addConfirmBtn" class="btn-xs">Add</button>
              <button id="addCancelBtn" class="btn-xs">Cancel</button>
            </div>
          </div>

          <div class="mt-3 flex items-center gap-2">
            <button id="addOutlineItem" class="px-3 py-2 rounded-xl border border-[var(--border)] text-sm">+ Add Section</button>
            <div id="totalMins" class="ml-auto text-xs muted">Total: 0 minutes</div>
          </div>
        </div>
      </aside>
    </div>

    <footer class="mt-10 text-center text-xs muted">
      Skillflow — minimal, keyboard-friendly session manager. ♟️
    </footer>
  </section>

  <!-- SAVED OUTLINES -->
  <section id="savedTab" class="hidden">
    <div id="mergeBar" class="card p-4 mb-4" style="display:none">
      <div class="flex flex-col gap-2">
        <div class="text-sm">Merge <strong id="mergeSourceName"></strong> ➕ <strong id="mergeTargetName"></strong></div>
        <div class="flex flex-wrap items-center gap-2">
          <label class="text-sm muted">New outline name</label>
          <input id="mergeTitleInput" class="input flex-1" placeholder="e.g. ‘Balanced + Openings’"/>
          <button id="mergeConfirmBtn" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white text-sm">Merge</button>
          <button id="mergeCancelBtn" class="px-3 py-2 rounded-xl border border-[var(--border)] text-sm">Cancel</button>
        </div>
        <div class="text-xs muted">Original outlines are kept. Sections from the dragged outline are appended after the target’s sections.</div>
      </div>
    </div>

    <div class="mb-3 flex flex-wrap items-center gap-2">
      <button id="createOutlineBtn" class="px-3 py-2 rounded-xl border border-[var(--border)] text-sm">+ Create new outline</button>
      <button id="createFolderBtn" class="px-3 py-2 rounded-xl border border-[var(--border)] text-sm">+ New folder</button>
      <div id="createOutlineForm" class="card p-4 mb-0 hidden">
        <label class="text-sm">Outline title</label>
        <div class="mt-2 flex items-center gap-2">
          <input id="newOutlineTitle" class="input flex-1" placeholder="e.g., 90-min Balanced Plan"/>
          <button id="createOutlineConfirm" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white text-sm">Create</button>
          <button id="createOutlineCancel" class="px-3 py-2 rounded-xl border border-[var(--border)] text-sm">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Breadcrumb path (drag targets) -->
    <div id="savedPathBar" class="card p-3 mb-3"></div>

    <div class="text-sm muted mb-3">Tip: drag one outline card onto another to propose a merge (only when NOT editing). You can also drag an outline onto a folder or onto a breadcrumb to move it.</div>
    <div id="savedList" class="grid lg:grid-cols-2 gap-4"></div>
  </section>

  <!-- HELP -->
  <section id="helpTab" class="hidden">
    <div class="card p-5">
      <h3 class="block-title mb-2">How to use</h3>
      <ol class="list-decimal pl-6 space-y-1 text-sm">
        <li>Create or load a saved outline on the right.</li>
        <li>Start the session timer, then jump between sections using the progress bar or outline.</li>
        <li>Edit links/notes for the current section with “Edit Section”.</li>
        <li>In Saved Outlines, drag a plan onto another to merge them or into folders to organize.</li>
        <li>Open ⚙️ Settings to tweak theme, defaults, and alert sound.</li>
      </ol>
    </div>
  </section>
</div>

<!-- FOCUS MODE OVERLAY -->
<div id="focusOverlay" class="fixed inset-0 hidden z-[100]">
  <div class="absolute inset-0 bg-[var(--bg)]"></div>
  <div class="relative z-10 w-full h-full flex items-center justify-center p-6">
    <div class="max-w-4xl w-full">
      <div class="flex items-center justify-end mb-4">
        <button id="focusExitBtn" class="px-3 py-2 rounded-xl border border-[var(--border)]">Exit Focus ✕</button>
      </div>

      <!-- Centered card stack -->
      <div class="card p-6 flex flex-col items-center text-center gap-5">
        <h2 id="focusTitle" class="text-3xl sm:text-4xl font-extrabold tracking-tight">—</h2>
        <div id="focusMeta" class="muted text-sm"></div>
        <div id="focusClock" class="clock-badge text-4xl tabular-nums">00:00</div>

        <!-- Progress (focus) -->
        <div class="w-full max-w-3xl">
          <div class="mb-1 flex items-center justify-between">
            <div class="block-sub">Progress</div>
            <div id="focusProgressPct" class="text-xs muted">0%</div>
          </div>
          <div id="focusProgressHost" class="relative w-full h-8 rounded-2xl overflow-hidden card">
            <div id="focusProgressFill" class="absolute left-0 top-0 bottom-0 transition-[width]" style="width:0%"></div>
            <div id="focusProgressSegments" class="absolute inset-0 flex"></div>
            <div id="focusProgressTicks" class="absolute inset-0 pointer-events-none"></div>
            <div id="focusScrubOverlay" class="absolute inset-0 cursor-pointer"></div>
          </div>
        </div>

        <!-- Controls -->
        <div class="flex items-center justify-center gap-3">
          <button id="focusStartBtn" class="px-4 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 text-white shadow-sm">Start Study Session</button>
          <button id="focusPauseBtn" class="px-4 py-2 rounded-xl border border-[var(--border)]">Pause</button>
          <button id="focusReadyNextBtn" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white shadow-sm hidden">
            I’m ready — start next ▶
          </button>
        </div>

        <!-- Links (focus) -->
        <div id="focusLinksWrap" class="w-full max-w-3xl">
          <div class="flex items-center justify-between mt-2">
            <h3 class="block-title">Links</h3>
          </div>
          <div id="focusLinks" class="section-links-bar mt-2"></div>
        </div>

        <!-- Notes -->
        <div id="focusDesc" class="text-sm whitespace-pre-wrap max-w-3xl w-full px-4 py-3 rounded-xl border border-[var(--border)] bg-[var(--panel)]"></div>
      </div>
    </div>
  </div>
</div>

<!-- SETTINGS MODAL -->
<div id="settingsModal" class="modal hidden" aria-hidden="true">
  <div class="modal-backdrop" data-close="1"></div>
  <div class="modal-panel max-w-[720px]" role="dialog" aria-modal="true">
    <div class="flex items-center justify-between mb-3">
      <h3 class="text-lg font-semibold">Appearance & Sound</h3>
      <button class="btn-xxs" data-close="1">✕</button>
    </div>

    <div class="grid grid-cols-2 gap-3">
      <label class="flex flex-col gap-1"><span class="text-sm">Background</span><input id="setBg" type="color" class="input h-10 p-1"/></label>
      <label class="flex flex-col gap-1"><span class="text-sm">Text</span><input id="setFg" type="color" class="input h-10 p-1"/></label>
      <label class="flex flex-col gap-1"><span class="text-sm">Accent</span><input id="setAccent" type="color" class="input h-10 p-1"/></label>
      <label class="flex flex-col gap-1"><span class="text-sm">Border</span><input id="setBorder" type="color" class="input h-10 p-1"/></label>
      <label class="flex flex-col gap-1"><span class="text-sm">Border width (px)</span><input id="setBorderW" type="number" min="0" max="6" step="1" class="input"/></label>
      <label class="col-span-2 flex items-center gap-2 mt-1">
        <input id="setFocusDefault" type="checkbox"/> <span>Start in focus mode by default</span>
      </label>
    </div>

    <div class="mt-5">
      <div class="block-title mb-2">Sound</div>
      <div class="grid md:grid-cols-3 gap-3">
        <label class="flex flex-col gap-1"><span class="text-sm">Ringtone</span>
          <select id="ringTone" class="input">
            <option value="chime">Chime</option>
            <option value="ping">Ping</option>
            <option value="bell">Bell</option>
            <option value="digital">Digital</option>
          </select>
        </label>
        <label class="flex flex-col gap-1"><span class="text-sm">Duration (ms)</span><input id="ringDur" type="number" min="100" step="50" class="input" /></label>
        <label class="flex flex-col gap-1"><span class="text-sm">Volume</span><input id="ringVol" type="range" min="0" max="1" step="0.01" class="w-full"/></label>
      </div>
      <div class="mt-2 flex items-center gap-2">
        <button id="ringPreview" class="px-3 py-2 rounded-xl border border-[var(--border)]">Preview</button>
        <span id="ringVolVal" class="text-xs muted">0.10</span>
      </div>
    </div>

    <div class="mt-5 flex items-center justify-between">
      <button id="settingsDefaultBtn" class="px-3 py-2 rounded-xl border border-[var(--border)]">Default</button>
      <div class="flex items-center gap-2">
        <button class="px-3 py-2 rounded-xl border border-[var(--border)]" data-close="1">Close</button>
        <button id="settingsSaveBtn" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white">Save</button>
      </div>
    </div>
  </div>
</div>

<!-- AUTH MODAL (unchanged structure) -->
<div id="authModal" class="modal hidden" aria-hidden="true">
  <div class="modal-backdrop" data-close="1"></div>
  <div class="modal-panel max-w-[520px]" role="dialog" aria-modal="true">
    <div class="mb-4">
      <div class="flex items-center justify-between">
        <h3 id="authTitle" class="text-xl font-semibold">Welcome back</h3>
        <button class="btn-xxs" data-close="1">✕</button>
      </div>
      <p id="authSubtitle" class="text-sm muted mt-1">Sign in to sync your data across devices.</p>
    </div>

    <div class="space-y-3">
      <button id="googleBtn" class="w-full px-3 py-2 rounded-xl border border-[var(--border)] flex items-center justify-center gap-2">
        <img alt="" src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" class="w-5 h-5"/> Continue with Google
      </button>

      <div class="auth-sep"><span>or</span></div>

      <div id="emailFields" class="grid gap-2">
        <input id="emailInput" type="email" class="input" placeholder="Email"/>
        <input id="passInput" type="password" class="input" placeholder="Password"/>
      </div>

      <div id="signinRow" class="flex flex-wrap gap-3 justify-center">
        <button id="emailSignInBtn" class="px-3 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 text-white btn-wide">Sign in</button>
        <button id="emailResetBtn" class="px-3 py-2 rounded-xl border border-[var(--border)] btn-wide">Reset password</button>
      </div>

      <div id="signupRow" class="hidden flex justify-center">
        <button id="emailSignUpBtn" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white btn-wide">Create account</button>
      </div>

      <div class="text-sm text-center mt-2">
        <span id="toggleAuthMode" class="underline cursor-pointer">New here? Create an account</span>
      </div>
    </div>
  </div>
</div>

<!-- App -->
<script type="module">
  /*************** Firebase ***************/
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-analytics.js";
  import {
    getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut,
    createUserWithEmailAndPassword, signInWithEmailAndPassword, sendPasswordResetEmail
  } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, serverTimestamp, deleteField } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

  import { setupSavedOutlines } from "./saved-outlines.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAMyUlfqqOlnt-kHO-C-vB_rzJ-9eudxck",
    authDomain: "chessstudyplanner.firebaseapp.com",
    projectId: "chessstudyplanner",
    storageBucket: "chessstudyplanner.firebasestorage.app",
    messagingSenderId: "73363049381",
    appId: "1:73363049381:web:48da4a1e06b9744fccf64c",
    measurementId: "G-8PE090JLZH"
  };
  const app = initializeApp(firebaseConfig);
  getAnalytics(app);

  /*************** Local state + helpers ***************/
  const saveJSON = (k,v)=> localStorage.setItem(k, JSON.stringify(v));
  const loadJSON = (k)=> { try{ return JSON.parse(localStorage.getItem(k)); }catch{ return null } };
  const $ = (q)=> document.querySelector(q);

  // Primary state
  let currentSession = loadJSON('current_session_v1') || [];
  let sectionNotes   = loadJSON('section_notes_v1') || {};
  let widgetShelf    = loadJSON('linkShelf_v1')    || [
    { id:'w_lichess',  label:'Lichess',          url:'https://lichess.org',          icon:'img',   img:'https://lichess1.org/assets/logo/lichess-favicon-256.png' },
    { id:'w_analysis', label:'Lichess Analysis', url:'https://lichess.org/analysis', icon:'img',   img:'https://lichess1.org/assets/logo/lichess-favicon-256.png' },
    { id:'w_chessable',label:'Chessable',        url:'https://www.chessable.com',    icon:'emoji', emoji:'📘' }
  ];
  let prefs = loadJSON('prefs_v1') || {
    splitRatio:56, outlineCollapsed:false, focusDefault:false,
    theme:{ bg:'#ffffff', fg:'#0f172a', accent:'#0ea5e9', border:'#94a3b8', borderW:2 },
    sound:{ name:'chime', duration:800, volume:0.12 }
  };
  let savedOutlines = loadJSON('saved_outlines_v1') || [];
  let timerState = loadJSON('timer_state_v2') || { sessionStarted:false, running:false, currentIndex:0, secondsLeft:0, outlineId:null, lastSyncTs:0, awaitingNext:false };

  // Cloud
  const auth = getAuth(app);
  const db = getFirestore(app);
  const provider = new GoogleAuthProvider(); provider.setCustomParameters({ prompt: "select_account" });
  const cloudStatus = $('#cloudStatus');
  let currentUser = null;
  const userDocRef = (uid)=> doc(db, 'users', uid, 'apps', 'chess_planner_v2');

  const debounce = (fn,ms=1000)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms);} };
  let dirty = false;
  const markDirty = ()=> { dirty = true; };
  const setLocalMode = (m='Local mode')=> cloudStatus.textContent = m;
  const setCloudMode = (m='Cloud sync on')=> cloudStatus.textContent = m;

  const saveCloudDebounced = debounce(async ()=>{
    if(!currentUser) return;
    try{
      await setDoc(userDocRef(currentUser.uid), {
        currentSession, notes: sectionNotes, prefs, widgetShelf,
        savedOutlines, timer: timerState, updatedAt: serverTimestamp(),
        sessions: deleteField(), activePreset: deleteField()
      }, { merge:true });
      cloudStatus.textContent = 'Saved to cloud ✓';
      dirty = false;
    }catch(e){ cloudStatus.textContent='Cloud save failed'; }
  }, 1200);

  const touchCloud = ()=> { if(currentUser){ saveCloudDebounced(); } };

  // Periodic flush
  setInterval(()=>{ if(currentUser && dirty) saveCloudDebounced(); }, 5000);
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden'){ if(currentUser) saveCloudDebounced(); } });
  window.addEventListener('beforeunload', ()=>{ if(currentUser) saveCloudDebounced(); });

  // Local save wrappers
  const saveCurrentSession = ()=>{ saveJSON('current_session_v1', currentSession); markDirty(); touchCloud(); };
  const saveNotes          = ()=>{ saveJSON('section_notes_v1', sectionNotes);     markDirty(); touchCloud(); };
  const saveShelf          = ()=>{ saveJSON('linkShelf_v1', widgetShelf);         markDirty(); touchCloud(); };
  const savePrefs          = ()=>{ saveJSON('prefs_v1', prefs);                   markDirty(); touchCloud(); };
  const saveOutlinesLocal  = ()=>{ saveJSON('saved_outlines_v1', savedOutlines);  markDirty(); touchCloud(); };
  const saveTimerLocal     = ()=>{ saveJSON('timer_state_v2', timerState);        markDirty(); touchCloud(); };

  /*************** Tabs ***************/
  const homeTab=$('#homeTab'); const savedTab=$('#savedTab'); const helpTab=$('#helpTab'); const overviewTab=$('#overviewTab');

  function showTab(id){
    document.querySelectorAll('.tab-link').forEach(b=>b.classList.remove('active'));
    const btn = document.querySelector(`.tab-link[data-tab="${id}"]`);
    if(btn) btn.classList.add('active');

    const ids = ['overviewTab','homeTab','savedTab','helpTab','pricingTab'];
    ids.forEach(secId=>{
      const el = document.getElementById(secId);
      if(el) el.classList.toggle('hidden', secId !== id);
    });

    if(id==='savedTab') renderSavedOutlines();
    if(id==='homeTab') renderHomeSavedBar();
  }

  const tabsBar = document.querySelector('nav .tabs-bar');
  if(tabsBar){
    tabsBar.addEventListener('click', (e)=>{
      const btn = e.target.closest('.tab-link'); if(!btn) return; showTab(btn.dataset.tab);
    });
  }
  document.querySelectorAll('[data-tab-jump]').forEach(b=> b.onclick = ()=> showTab(b.dataset.tabJump));

  /*************** Progress / Timer ***************/
  const startBtn = $('#startBtn'); const prevBtn=$('#prevBtn'); const nextBtn=$('#nextBtn'); const resetBtn=$('#resetBtn');
  const readyNextBtn = $('#readyNextBtn');

  const currentTitleEl = $('#currentTitle'); const sectionDescEl=$('#sectionDesc'); const linksDiv=$('#links');
  const linkShelfDiv=$('#linkShelf'); const shelfWrap=$('#shelfWrap'); const editSectionBtn=$('#editSectionBtn'); const clearSectionLinksBtn=$('#clearSectionLinks');
  const addWidgetBtn=$('#addWidgetBtn'); const resetShelfBtn=$('#resetShelfBtn');

  // Inline edit handles (title & duration)
  const editTitleInline = $('#editTitleInline');
  const currentDurDisp  = $('#currentDurDisp');
  const editDurInline   = $('#editDurInline');
  const editMinsInline  = $('#editMinsInline');
  const editUnitInline  = $('#editUnitInline');

  const outline=$('#outline'); const addOutlineItemBtn=$('#addOutlineItem'); const inlineAddRow=$('#inlineAddRow');
  const addTitleInput=$('#addTitleInput'); const addMinsInput=$('#addMinsInput'); const addConfirmBtn=$('#addConfirmBtn'); const addCancelBtn=$('#addCancelBtn');
  const totalMins=$('#totalMins'); const clockEl=$('#clock');

  const progressHost=$('#progressHost'), progressFill=$('#progressFill'), progressSegments=$('#progressSegments'),
        progressTicks=$('#progressTicks'), progressPctEl=$('#progressPct'), legend=$('#legend'), scrubOverlay=$('#scrubOverlay'), progressTotalEl=$('#progressTotal');

  // Focus Mode elements
  const focusOverlay = $('#focusOverlay');
  const focusModeBtn = $('#focusModeBtn');
  const focusExitBtn = $('#focusExitBtn');
  const focusTitleEl = $('#focusTitle');
  const focusMetaEl  = $('#focusMeta');
  const focusDescEl  = $('#focusDesc');
  const focusClockEl = $('#focusClock');
  const focusStartBtn= $('#focusStartBtn');
  const focusPauseBtn= $('#focusPauseBtn');
  const focusReadyBtn= $('#focusReadyNextBtn');

  const focusProgressHost=$('#focusProgressHost'), focusProgressFill=$('#focusProgressFill'),
        focusProgressSegments=$('#focusProgressSegments'), focusProgressTicks=$('#focusProgressTicks'),
        focusProgressPctEl=$('#focusProgressPct'), focusScrubOverlay=$('#focusScrubOverlay');

  const focusLinksDiv = $('#focusLinks');

  // Split panes
  const splitEl = $('#split'), leftPane = $('#leftPane'), rightPane = $('#rightPane'), splitHandle = $('#splitHandle');
  function applySplitRatio(r){ splitEl.style.setProperty('--leftRatio', (r||56) + '%'); }
  applySplitRatio(prefs.splitRatio||56);
  let draggingSplit=false, splitLast= prefs.splitRatio||56;
  splitHandle.addEventListener('pointerdown', (e)=>{ draggingSplit=true; splitHandle.setPointerCapture(e.pointerId); document.body.classList.add('no-select'); onSplitMove(e); });
  splitHandle.addEventListener('pointermove', (e)=>{ if(draggingSplit) onSplitMove(e); });
  splitHandle.addEventListener('pointerup', ()=>{ if(!draggingSplit) return; draggingSplit=false; document.body.classList.remove('no-select'); prefs.splitRatio = Math.round(splitLast*10)/10; savePrefs(); });
  function onSplitMove(e){
    const rect = splitEl.getBoundingClientRect();
    const x = Math.max(rect.left, Math.min(e.clientX, rect.right));
    const total = rect.width;
    const minPx = 360; const minPct = (minPx/total)*100;
    let pct = ((x - rect.left)/total)*100;
    pct = Math.max(minPct, Math.min(100 - minPct, pct));
    splitLast = pct;
    applySplitRatio(pct);
  }

  function minsToSecs(m){ return Math.max(0, Math.round(m*60)); }
  function secsToClock(s){ const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(Math.floor(s%60)).padStart(2,'0'); return `${mm}:${ss}`; }
  function scheduleTotalSecs(s){ return s.reduce((a,b)=>a+minsToSecs(b.minutes||0),0); }
  function elapsedSeconds(sched, idx, secsLeft){ const past=sched.slice(0,idx).reduce((a,b)=>a+minsToSecs(b.minutes||0),0); const cur=sched[idx]?minsToSecs(sched[idx].minutes||0)-secsLeft:0; return past+cur; }
  function toMinutesValue(value, unit){ const v=Number(value)||0; if(unit==='seconds') return v/60; if(unit==='hours') return v*60; return v; }

  let running=false, rafId=null, bgTickId=null, endTimeMs=null, secondsLeft=0, currentIndex=0, sessionStarted=false, totalSessionSecs=0, awaitingNext=false;

  function isAtVeryStart(){
    if(!currentSession.length) return true;
    return elapsedSeconds(currentSession, currentIndex, secondsLeft) === 0;
  }

  function setClockText(txt){
    if(clockEl) clockEl.textContent = txt;
    if(focusClockEl) focusClockEl.textContent = txt;
  }
  function updateClockColor(){
    const apply = (el)=>{ if(!el) return; el.classList.remove('text-emerald-600','text-rose-600'); if(sessionStarted){ (running?el.classList.add('text-emerald-600'):el.classList.add('text-rose-600')); } };
    apply(clockEl); apply(focusClockEl);
  }
  function updateStartBtnLabel(){
    const label = running ? 'Pause Session' : (isAtVeryStart() ? 'Start Study Session' : 'Resume Session');
    if(startBtn) startBtn.textContent = label;
    if(focusStartBtn) focusStartBtn.textContent = label;
    const disable = !!awaitingNext;
    if(startBtn) startBtn.disabled = disable;
    if(focusStartBtn) focusStartBtn.disabled = disable;
  }

  function setTimerFromState(st){
    sessionStarted=!!st.sessionStarted; running=false; currentIndex=st.currentIndex||0; secondsLeft=Math.max(0,Math.round(st.secondsLeft||0));
    awaitingNext = !!st.awaitingNext;
    if(st.running && st.lastSyncTs){
      let delta=Math.floor((Date.now()-st.lastSyncTs)/1000), idx=currentIndex, remain=secondsLeft;
      while(delta>0 && currentSession[idx]){
        if(delta>=remain){ delta-=remain; idx++; remain=currentSession[idx]?minsToSecs(currentSession[idx].minutes||0):0; }
        else{ remain-=delta; delta=0; }
      }
      currentIndex=Math.min(idx, Math.max(0,currentSession.length-1)); secondsLeft=Math.max(0,remain||0);
    }
    totalSessionSecs=scheduleTotalSecs(currentSession);
    renderAll();
    if(awaitingNext) showNextGate(); else hideNextGate();
    updateStartBtnLabel();
  }
  function syncEnd(){ endTimeMs = performance.now() + secondsLeft * 1000; }
  function tick(){
    if(!running) return;
    const remaining = Math.max(0, Math.ceil((endTimeMs - performance.now())/1000));
    if(remaining !== secondsLeft){
      secondsLeft = remaining;
      setClockText(secsToClock(secondsLeft));
      updateProgress();
    }
    if(secondsLeft <= 0){
      if(currentIndex < currentSession.length - 1){
        stopTimer(); awaitingNext = true; showNextGate(); playAlert(); markTimer(); return;
      } else {
        stopTimer(); playAlert(); sessionStarted = false; updateStartBtnLabel(); markTimer(); alert('Session complete! 🎉'); return;
      }
    }
  }
  function startTimer(){ if(running) return; running = true; syncEnd(); loop(); if(bgTickId) clearInterval(bgTickId); bgTickId = setInterval(tick, 1000); updateStartBtnLabel(); updateClockColor(); markTimer(); }
  function stopTimer(){ running = false; if(rafId) cancelAnimationFrame(rafId); rafId = null; if(bgTickId) clearInterval(bgTickId);  bgTickId = null; updateStartBtnLabel(); updateClockColor(); markTimer(); }
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState === 'hidden'){ if(running) tick(); } });
  function loop(){ if(!running) return; tick(); rafId = requestAnimationFrame(loop); }
  const markTimer = ()=>{ timerState={ sessionStarted,running,currentIndex,secondsLeft,lastSyncTs:Date.now(), awaitingNext }; saveTimerLocal(); };

  function proceedNext(){ if(!awaitingNext) return; awaitingNext=false; hideNextGate(); if(currentIndex<currentSession.length-1){ currentIndex++; secondsLeft=minsToSecs(currentSession[currentIndex].minutes||0); syncEnd(); startTimer(); renderAll(); markTimer(); } }
  function showNextGate(){ readyNextBtn.classList.remove('hidden'); if(focusReadyBtn) focusReadyBtn.classList.remove('hidden'); updateStartBtnLabel(); }
  function hideNextGate(){ readyNextBtn.classList.add('hidden'); if(focusReadyBtn) focusReadyBtn.classList.add('hidden'); updateStartBtnLabel(); }
  readyNextBtn.onclick = proceedNext; if(focusReadyBtn) focusReadyBtn.onclick = proceedNext;

  startBtn.onclick = ()=>{ if(!currentSession.length) return; if(awaitingNext) return; if(!sessionStarted){ currentIndex=0; secondsLeft=minsToSecs(currentSession[0].minutes||0); totalSessionSecs=scheduleTotalSecs(currentSession); sessionStarted=true; markTimer(); startTimer(); } else { running?stopTimer():startTimer(); } };
  if(focusStartBtn){ focusStartBtn.onclick = ()=> startBtn.click(); }
  if(focusPauseBtn){ focusPauseBtn.onclick = ()=>{ if(running) stopTimer(); }; }
  prevBtn.onclick = ()=>{ awaitingNext=false; hideNextGate(); if(currentIndex>0){ currentIndex--; secondsLeft=minsToSecs(currentSession[currentIndex].minutes||0); if(running) syncEnd(); renderAll(); markTimer(); } updateStartBtnLabel(); };
  nextBtn.onclick = ()=>{ awaitingNext=false; hideNextGate(); if(currentIndex<currentSession.length-1){ currentIndex++; secondsLeft=minsToSecs(currentSession[currentIndex].minutes||0); if(running) syncEnd(); renderAll(); markTimer(); } else stopTimer(); updateStartBtnLabel(); };

  // Reset now reloads from Saved Outlines (defaults)
  function findOutlineByIdDeep(id, arr){
    for(const it of (arr||[])){
      if(it?.id===id && it?.sections) return it;
      if(it?.type==='folder' && it?.children){ const r=findOutlineByIdDeep(id, it.children); if(r) return r; }
    }
    return null;
  }
  resetBtn.onclick = ()=>{
    awaitingNext=false; hideNextGate(); stopTimer();
    const activeId = (timerState && timerState.outlineId) || null;
    if(activeId){
      const base = findOutlineByIdDeep(activeId, savedOutlines);
      if(base){ applyOutlineToCurrent(base); return; }
    }
    sessionStarted=false; currentIndex=0; secondsLeft=minsToSecs((currentSession[0]||{}).minutes||0); renderAll(); updateStartBtnLabel(); markTimer();
  };

  function buildProgress(){
    const sched=currentSession; const total=scheduleTotalSecs(sched)||1;
    progressSegments.innerHTML=''; legend.innerHTML=''; progressTicks.innerHTML='';
    sched.forEach(sec=>{ const w=(minsToSecs(sec.minutes||0)/total)*100; const seg=document.createElement('div'); seg.className='h-full relative bg-white/50'; seg.style.width=`${w}%`; progressSegments.appendChild(seg); });
    let cum=0; for(let i=1;i<sched.length;i++){ cum+=minsToSecs(sched[i-1].minutes||0); const pct=(cum/total)*100; const tick=document.createElement('div'); Object.assign(tick.style,{position:'absolute',left:pct+'%',top:'0',bottom:'0',width:'2px',background:'rgba(0,0,0,.55)'}); progressTicks.appendChild(tick); }
    sched.forEach((sec,i)=>{ const chip=document.createElement('button'); chip.type='button'; chip.className='chip'; chip.dataset.idx=String(i); chip.innerHTML=`${escapeHtml(sec.name||'')} <span class="opacity-80">(${sec.minutes||0}m)</span>`; chip.onclick=()=>jumpToSection(i); legend.appendChild(chip); });
    progressTotalEl.textContent = `Total: ${Math.round(total/60)}m`;
    updateProgress();
    buildFocusProgress();
  }
  function buildFocusProgress(){
    if(!focusProgressHost) return;
    const sched=currentSession; const total=scheduleTotalSecs(sched)||1;
    focusProgressSegments.innerHTML=''; focusProgressTicks.innerHTML='';
    sched.forEach(sec=>{ const w=(minsToSecs(sec.minutes||0)/total)*100; const seg=document.createElement('div'); seg.className='h-full relative bg-white/50'; seg.style.width=`${w}%`; focusProgressSegments.appendChild(seg); });
    let cum=0; for(let i=1;i<sched.length;i++){ cum+=minsToSecs(sched[i-1].minutes||0); const pct=(cum/total)*100; const tick=document.createElement('div'); Object.assign(tick.style,{position:'absolute',left:pct+'%',top:'0',bottom:'0',width:'2px',background:'rgba(0,0,0,.55)'}); focusProgressTicks.appendChild(tick); }
    updateFocusProgress();
  }
  function updateLegendActive(){ legend.querySelectorAll('.chip').forEach((el, i)=> el.classList.toggle('chip-active', i===currentIndex)); }
  function updateProgress(){
    const sched=currentSession; const total=scheduleTotalSecs(sched);
    if(!total){ progressFill.style.width='0%'; progressPctEl.textContent='0%'; progressTotalEl.textContent='Total: 0m'; return; }
    const pct=Math.min(100,Math.max(0,(elapsedSeconds(sched,currentIndex,secondsLeft)/total)*100));
    progressFill.style.width = pct + '%';
    progressPctEl.textContent = Math.floor(pct) + '%';
    progressTotalEl.textContent = `Total: ${Math.round(total/60)}m`;
    updateLegendActive(); updateStartBtnLabel(); updateFocusProgress();
  }
  function updateFocusProgress(){
    if(!focusProgressFill || !focusProgressPctEl) return;
    const sched=currentSession; const total=scheduleTotalSecs(sched);
    if(!total){ focusProgressFill.style.width='0%'; focusProgressPctEl.textContent='0%'; return; }
    const pct=Math.min(100,Math.max(0,(elapsedSeconds(sched,currentIndex,secondsLeft)/total)*100));
    focusProgressFill.style.width = pct + '%';
    focusProgressPctEl.textContent = Math.floor(pct) + '%';
  }

  function pctFromEvent(e){ const rect=progressHost.getBoundingClientRect(); const x=(e.clientX ?? (e.touches?.[0]?.clientX ?? 0))-rect.left; return Math.max(0,Math.min(1,x/rect.width)); }
  function pctFromEventFocus(e){ const rect=focusProgressHost.getBoundingClientRect(); const x=(e.clientX ?? (e.touches?.[0]?.clientX ?? 0))-rect.left; return Math.max(0,Math.min(1,x/rect.width)); }
  function jumpFromPct(p){
    const sched=currentSession; const total=scheduleTotalSecs(sched); let target=p*total; let cum=0;
    for(let i=0;i<sched.length;i++){
      const dur=minsToSecs(sched[i].minutes||0);
      if(target<cum+dur){
        currentIndex=i; secondsLeft=Math.max(0,Math.ceil(dur-(target-cum))); if(running) syncEnd(); renderAll(); markTimer(); awaitingNext=false; hideNextGate(); updateStartBtnLabel(); return;
      }
      cum+=dur;
    }
    currentIndex=sched.length-1; secondsLeft=0; stopTimer(); renderAll(); markTimer(); awaitingNext=false; hideNextGate(); updateStartBtnLabel();
  }
  let scrubbing=false; scrubOverlay.addEventListener('pointerdown',(e)=>{scrubbing=true;scrubOverlay.setPointerCapture(e.pointerId);jumpFromPct(pctFromEvent(e));}); scrubOverlay.addEventListener('pointermove',(e)=>{if(scrubbing)jumpFromPct(pctFromEvent(e));}); scrubOverlay.addEventListener('pointerup',()=>{scrubbing=false;}); scrubOverlay.addEventListener('pointercancel',()=>{scrubbing=false;});
  let focusScrubbing=false; if(focusScrubOverlay){ focusScrubOverlay.addEventListener('pointerdown',(e)=>{focusScrubbing=true;focusScrubOverlay.setPointerCapture(e.pointerId);jumpFromPct(pctFromEventFocus(e));}); focusScrubOverlay.addEventListener('pointermove',(e)=>{if(focusScrubbing)jumpFromPct(pctFromEventFocus(e));}); focusScrubOverlay.addEventListener('pointerup',()=>{focusScrubbing=false;}); focusScrubOverlay.addEventListener('pointercancel',()=>{focusScrubbing=false;}); }
  function jumpToSection(i){ if(!currentSession[i]) return; awaitingNext=false; hideNextGate(); currentIndex=i; secondsLeft=minsToSecs(currentSession[i].minutes||0); if(running) syncEnd(); renderAll(); markTimer(); updateStartBtnLabel(); }

  /*************** Helpers ***************/
  function escapeHtml(s){ return (s??'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
  function parseDropPayload(dt){
    let data=''; const types = dt?.types ? Array.from(dt.types) : [];
    if(types.includes('text/plain')) data = dt.getData('text/plain');
    if(!data && types.includes('text')) data = dt.getData('text');
    if(!data) data = dt.getData('application/json') || dt.getData('Text') || '';
    try{ return JSON.parse(data); }catch{ return null; }
  }
  function normalizeUrl(input){
    let u = (input || '').trim(); if(!u) return '';
    if(/^https?:\/\//i.test(u)) return u;
    u = u.replace(/^\/\//,'');
    const slash = u.indexOf('/'); let host = slash >= 0 ? u.slice(0, slash) : u; const rest = slash >= 0 ? u.slice(slash) : '';
    if(!/^www\./i.test(host)){ const parts = host.split('.'); if(parts.length === 2){ host = 'www.' + host; } }
    return 'https://' + host + rest;
  }

  // Open a small link editor (shared with Saved)
  function openWidgetEditor(widget, onSave, onCancel){
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-backdrop" data-close="1"></div>
      <div class="modal-panel max-w-[520px]">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-semibold">Edit link</h3>
          <button class="btn-xxs" data-close="1">✕</button>
        </div>
        <div class="grid gap-2">
          <label class="text-sm">Title
            <input id="wLabel" class="input mt-1" value="${escapeHtml(widget.label || '')}"/>
          </label>
          <label class="text-sm">URL
            <input id="wUrl" class="input mt-1" value="${escapeHtml(widget.url || '')}" placeholder="https://… or aimchess.com"/>
          </label>
          <label class="text-sm">Icon type
            <select id="wIcon" class="input mt-1">
              <option value="emoji" ${widget.icon!=='img'?'selected':''}>Emoji/Text</option>
              <option value="img"   ${widget.icon==='img'?'selected':''}>Image URL</option>
            </select>
          </label>
          <label class="text-sm" id="emojiRow">Emoji/Text
            <input id="wEmoji" class="input mt-1" value="${escapeHtml(widget.emoji || '')}" placeholder="♟️"/>
          </label>
          <label class="text-sm hidden" id="imgRow">Image URL
            <input id="wImg" class="input mt-1" value="${escapeHtml(widget.img || '')}" placeholder="https://…/icon.png"/>
          </label>
        </div>
        <div class="mt-3 flex items-center justify-end gap-2">
          <button class="px-3 py-2 rounded-xl border border-[var(--border)]" data-close="1">Cancel</button>
          <button id="wSave" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white">Save</button>
        </div>
      </div>`;
    document.body.appendChild(modal);
    const iconSel = modal.querySelector('#wIcon'); const emojiRow = modal.querySelector('#emojiRow'); const imgRow   = modal.querySelector('#imgRow');
    const syncRows = ()=>{ const useImg = iconSel.value==='img'; emojiRow.classList.toggle('hidden', useImg); imgRow.classList.toggle('hidden', !useImg); };
    syncRows(); iconSel.addEventListener('change', syncRows);
    const close = ()=>{ modal.classList.add('hidden'); setTimeout(()=>modal.remove(), 140); };
    modal.addEventListener('click', (e)=>{ if(e.target.dataset.close==='1'){ onCancel && onCancel(); close(); } });
    const onEsc = (e)=>{ if(e.key==='Escape'){ onCancel && onCancel(); close(); document.removeEventListener('keydown', onEsc);} }; document.addEventListener('keydown', onEsc);
    modal.querySelector('#wSave').onclick = ()=>{ const label = modal.querySelector('#wLabel').value.trim() || 'Untitled'; let url = modal.querySelector('#wUrl').value.trim() || ''; url = normalizeUrl(url); const icon  = iconSel.value==='img' ? 'img' : 'emoji'; let emoji='', img=''; if(icon==='img') img = modal.querySelector('#wImg').value.trim(); else emoji = modal.querySelector('#wEmoji').value.trim() || '🔗'; onSave({ label, url, icon, emoji, img }); onCancel = null; close(); };
  }

  /*************** Current panel ***************/
  let isEditingSection=false;

  // Autosize title input
  const titleMeasureEl = document.createElement('span');
  titleMeasureEl.style.cssText = 'position:fixed;top:-9999px;left:-9999px;visibility:hidden;white-space:pre;font-weight:800;font-size:1.5rem;font-family:inherit;padding:0.5rem 0.75rem;';
  document.body.appendChild(titleMeasureEl);
  function autosizeTitleInput(){ if(!editTitleInline) return; const val = editTitleInline.value || ' '; titleMeasureEl.textContent = val; const desired = Math.min(titleMeasureEl.offsetWidth + 24, Math.floor(window.innerWidth * 0.7)); editTitleInline.style.width = Math.max(desired, 140) + 'px'; }

  function saveMetaEdits(){
    const s = currentSession[currentIndex]; if(!s) return;
    const prevMinutes = Number(s.minutes) || 0; const prevTotalSec = minsToSecs(prevMinutes);
    const elapsedSec = Math.max(0, prevTotalSec - secondsLeft);
    const newTitle = (editTitleInline.value || '').trim() || s.name || 'Untitled';
    const newMinutes = Math.max(0.01, toMinutesValue(editMinsInline.value, editUnitInline.value));
    s.name = newTitle; s.minutes = newMinutes;
    if(currentSession[currentIndex]?.id === s.id){
      const newTotal = minsToSecs(newMinutes); secondsLeft = Math.max(0, newTotal - elapsedSec); if(running) syncEnd();
    }
    saveCurrentSession(); renderOutline(); buildProgress(); updateProgress(); renderCurrent(); updateStartBtnLabel(); markTimer(); syncSavedFromCurrent();
  }
  editSectionBtn.onclick = ()=>{ if(!isEditingSection){ isEditingSection = true; updateEditUI(); } else { saveMetaEdits(); isEditingSection = false; updateEditUI(); } };
  function updateEditUI(){
    shelfWrap.classList.toggle('hidden', !isEditingSection);
    clearSectionLinksBtn.classList.toggle('hidden', !isEditingSection);
    editSectionBtn.textContent = isEditingSection ? 'Save Changes' : 'Edit Section';
    const s = currentSession[currentIndex] || {};
    currentTitleEl.classList.toggle('hidden', isEditingSection);
    currentDurDisp.classList.toggle('hidden', isEditingSection);
    editTitleInline.classList.toggle('hidden', !isEditingSection);
    editDurInline.classList.toggle('hidden', !isEditingSection);
    if(isEditingSection){
      editTitleInline.value = s.name || ''; autosizeTitleInput(); editTitleInline.focus(); editTitleInline.select();
      editMinsInline.value  = (Number(s.minutes) || 0).toString(); editUnitInline.value  = 'minutes';
    }
    sectionDescEl.disabled = !isEditingSection;
    renderCurrentLinks(); renderShelf();
  }
  editTitleInline.addEventListener('input', autosizeTitleInput);
  window.addEventListener('resize', ()=>{ if(isEditingSection) autosizeTitleInput(); });

  const currentSectionRef = ()=> currentSession[currentIndex];

  // Shelf controls …
  addWidgetBtn.onclick = ()=>{ if(!isEditingSection) editSectionBtn.click(); const wid = 'W'+Date.now().toString(36); const placeholder = { id: wid, label:'', url:'', icon:'emoji', emoji:'🔗', img:'' }; widgetShelf = [...widgetShelf, placeholder]; saveShelf(); renderShelf(); const onCancel = ()=>{ const idx = widgetShelf.findIndex(x=>x.id===wid); if(idx>=0){ widgetShelf.splice(idx,1); saveShelf(); renderShelf(); } }; openWidgetEditor(placeholder, (upd)=>{ upd.url = normalizeUrl(upd.url); const it = widgetShelf.find(x=>x.id===wid); if(it){ Object.assign(it, upd); saveShelf(); renderShelf(); } }, onCancel); };
  resetShelfBtn.onclick = ()=>{ if(!confirm('Reset link shelf to defaults?')) return; widgetShelf = [
      { id:'w_lichess',  label:'Lichess',          url:'https://lichess.org',          icon:'img',   img:'https://lichess1.org/assets/logo/lichess-favicon-256.png' },
      { id:'w_analysis', label:'Lichess Analysis', url:'https://lichess.org/analysis', icon:'img',   img:'https://lichess1.org/assets/logo/lichess-favicon-256.png' },
      { id:'w_chessable',label:'Chessable',        url:'https://www.chessable.com',    icon:'emoji', emoji:'📘' }
    ]; saveShelf(); renderShelf(); };

  function widgetCardHTML(w){
    const iconHtml = (w.icon==='img' && w.img) ? `<img src="${escapeHtml(w.img)}" alt="" class="rounded-[4px] object-cover" draggable="false" style="width:18px;height:18px;"/>` : `<span class="link-icon">${escapeHtml(w.emoji || '🔗')}</span>`;
    return `
      <div class="widget" data-wid="${escapeHtml(w.id)}">
        <div class="link-card draggable-shelf" draggable="${isEditingSection?'true':'false'}" data-wid="${escapeHtml(w.id)}" title="${escapeHtml(w.url || '')}" style="cursor:${isEditingSection?'grab':'default'}">
          ${iconHtml}
          <div class="min-w-0">
            <div class="truncate" style="font-size:.95rem">${escapeHtml(w.label || 'Untitled')}</div>
            <div class="text-xs muted truncate">${escapeHtml(w.url || '')}</div>
          </div>
        </div>
        ${isEditingSection ? `<button class="bin" data-act="del-shelf" title="Delete from shelf">🗑️</button>` : ''}
      </div>`;
  }
  function renderShelf(){
    linkShelfDiv.innerHTML = (isEditingSection ? `<button class="add-pill" data-act="add-shelf"> Add</button>` : '')
      + widgetShelf.map(widgetCardHTML).join('');
    linkShelfDiv.querySelector('[data-act="add-shelf"]')?.addEventListener('click', ()=> addWidgetBtn.click());
    linkShelfDiv.querySelectorAll('.draggable-shelf').forEach(card=>{
      card.addEventListener('click', ()=>{ if(!isEditingSection) return; const w = widgetShelf.find(x=>x.id===card.dataset.wid); if(!w) return; openWidgetEditor(w, (upd)=>{ upd.url = normalizeUrl(upd.url); Object.assign(w, upd); saveShelf(); renderShelf(); }); });
      card.addEventListener('dragstart', e=>{ if(!isEditingSection){ e.preventDefault(); return; } const payloadStr = JSON.stringify({type:'shelf', id:card.dataset.wid}); try{ e.dataTransfer.setData('text/plain', payloadStr); }catch{} e.dataTransfer.effectAllowed='copy'; card.classList.add('drag-ghost'); });
      card.addEventListener('dragend', ()=> card.classList.remove('drag-ghost'));
    });
    linkShelfDiv.querySelectorAll('[data-act="del-shelf"]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{ e.stopPropagation(); if(!isEditingSection) return; const wid = btn.closest('[data-wid]')?.dataset.wid || btn.parentElement?.dataset.wid; const idx = widgetShelf.findIndex(x=>x.id===wid); if(idx>=0){ widgetShelf.splice(idx,1); saveShelf(); renderShelf(); } });
    });
  }

  // Links
  function renderCurrentLinks(){
    const sec=currentSectionRef(); const arr=sec?.links||[];
    linksDiv.innerHTML = arr.map((w,i)=>`
      <div class="widget" data-link-idx="${i}">
        <div class="link-card section-link" draggable="${isEditingSection?'true':'false'}" data-idx="${i}">
          ${w.icon==='img' && w.img ? `<img src="${escapeHtml(w.img)}" alt="" class="rounded-[4px] object-cover" draggable="false" style="width:18px;height:18px;"/>` : `<span class="link-icon">${escapeHtml(w.emoji||'🔗')}</span>`}
          <span class="truncate max-w-[14rem]">${escapeHtml(w.label||'Untitled')}</span>
        </div>
        ${isEditingSection ? `<button class="bin" data-act="del-link" title="Delete">🗑️</button>` : ''}
      </div>`).join('');

    linksDiv.querySelectorAll('.section-link').forEach(card=>{
      card.addEventListener('dragstart', e=>{ if(!isEditingSection){ e.preventDefault(); return; } const index=Number(card.dataset.idx); const payloadStr = JSON.stringify({type:'reorder', index}); try{ e.dataTransfer.setData('text/plain', payloadStr); }catch{} e.dataTransfer.effectAllowed='move'; card.classList.add('drag-ghost'); });
      card.addEventListener('dragend', ()=> card.classList.remove('drag-ghost'));
      card.addEventListener('click', ()=>{ const i = Number(card.dataset.idx); const target = sec.links[i]; if(!target) return; if(isEditingSection){ openWidgetEditor(target, (upd)=>{ upd.url = normalizeUrl(upd.url); Object.assign(target, upd); saveCurrentSession(); renderCurrentLinks(); renderFocusLinks(); syncSavedFromCurrent(); }); } else { const url = normalizeUrl(target.url||''); if(url) window.open(url, '_blank', 'noopener'); } });
    });

    if(isEditingSection){
      linksDiv.querySelectorAll('[data-act="del-link"]').forEach(btn=>{
        btn.addEventListener('click', (e)=>{ e.stopPropagation(); const pill = btn.closest('.widget')?.querySelector('.section-link'); const i = Number(pill?.dataset.idx ?? -1); if(i>=0){ sec.links.splice(i,1); saveCurrentSession(); renderCurrentLinks(); renderFocusLinks(); syncSavedFromCurrent(); } });
      });
    }
    renderFocusLinks();
  }

  clearSectionLinksBtn.onclick = ()=>{ if(!isEditingSection) return; const sec = currentSectionRef(); if(!sec || !sec.links || sec.links.length===0) return; if(!confirm('Clear all links for this section?')) return; sec.links = []; saveCurrentSession(); renderCurrentLinks(); renderFocusLinks(); syncSavedFromCurrent(); };
  let overCount = 0; linksDiv.addEventListener('dragenter', e=>{ if(!isEditingSection) return; overCount++; linksDiv.classList.add('drag-over-outline'); });
  linksDiv.addEventListener('dragleave', e=>{ if(!isEditingSection) return; overCount=Math.max(0, overCount-1); if(overCount===0) linksDiv.classList.remove('drag-over-outline'); });
  linksDiv.addEventListener('dragover', e=>{ if(!isEditingSection) return; e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
  linksDiv.addEventListener('drop', e=>{ if(!isEditingSection) return; e.preventDefault(); overCount=0; linksDiv.classList.remove('drag-over-outline'); const payload = parseDropPayload(e.dataTransfer); if(!payload) return; const sec=currentSectionRef(); if(!sec) return; if(payload.type==='shelf'){ const w=widgetShelf.find(x=>x.id===payload.id); if(!w) return; sec.links.push({ id:'l_'+Date.now()+Math.random().toString(16).slice(2), label:w.label, url:w.url, icon:w.icon, emoji:w.emoji||'', img:w.img||'' }); saveCurrentSession(); renderCurrentLinks(); renderFocusLinks(); syncSavedFromCurrent(); } else if(payload.type==='reorder'){ const from=payload.index; const cards=[...linksDiv.querySelectorAll('.section-link')]; let to=cards.length; for(let i=0;i<cards.length;i++){ const r=cards[i].getBoundingClientRect(); if(e.clientY < r.top + r.height/2){ to=i; break; } } if(from===to || from==null || to==null) return; const [m]=sec.links.splice(from,1); sec.links.splice(to,0,m); saveCurrentSession(); renderCurrentLinks(); renderFocusLinks(); syncSavedFromCurrent(); } });

  // Description (debounced sync)
  const syncSavedFromCurrentDebounced = debounce(()=>{ try{ syncSavedFromCurrent(); }catch{} }, 400);
  sectionDescEl.addEventListener('input', ()=>{ if(sectionDescEl.disabled) return; const s=currentSession[currentIndex]; if(!s) return; sectionNotes[s.id] = sectionDescEl.value; saveNotes(); syncSavedFromCurrentDebounced(); });

  /*************** Outline (Home) ***************/
  function renderOutline(){
    outline.innerHTML = currentSession.map((s,i)=>
      `<li class="outline-row ${i===currentIndex?'outline-active':''}" data-id="${s.id}" draggable="true">
        <div class="flex items-center gap-3">
          <button class="text-left min-w-0 flex-1 truncate text-sm font-semibold focus:outline-none">${escapeHtml(s.name||'')}</button>
          <div class="flex items-center gap-2 shrink-0">
            <span class="text-xs w-16 text-right">${Number(s.minutes||0)}m</span>
            <button class="btn-xs" data-act="edit">Edit</button>
            <button class="btn-xs" data-act="delete">Delete</button>
          </div>
        </div>
      </li>`).join('');

    // Jump on row click
    outline.querySelectorAll('li[data-id]').forEach((li, idx)=>{
      li.addEventListener('click', (e)=>{ if(li.classList.contains('editing')) return; if(e.target.closest('[data-act], input, select, textarea, button')) return; jumpToSection(idx); });
    });

    // Inline edit
    outline.querySelectorAll('[data-act="edit"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const li = btn.closest('li[data-id]'); const id = li.dataset.id; const idx=currentSession.findIndex(x=>x.id===id); if(idx<0) return; const cur=currentSession[idx];
        li.classList.add('editing'); li.draggable = false;
        li.innerHTML = `
          <div class="flex items-center gap-2">
            <input class="input w-56 md:w-72 text-sm" id="edtTitle" value="${escapeHtml(cur.name||'')}" />
            <input class="input w-24 text-sm" id="edtValue" type="number" step="0.1" min="0.01" value="${(+cur.minutes||0).toFixed(2).replace(/\.00$/,'')}" />
            <select id="edtUnit" class="input h-9 w-20 text-sm">
              <option value="minutes" selected>min</option>
              <option value="seconds">sec</option>
              <option value="hours">hr</option>
            </select>
            <button class="btn-xxs" id="edtSave">Save</button>
          </div>`;
        const edtTitle=li.querySelector('#edtTitle'), edtValue=li.querySelector('#edtValue'), edtUnit=li.querySelector('#edtUnit');
        const saveInline = ()=>{ const prevMin = cur.minutes; const prevTotal = minsToSecs(prevMin); const elapsedSec = currentSession[currentIndex]?.id===cur.id ? Math.max(0, prevTotal - secondsLeft) : 0;
          cur.name = (edtTitle.value.trim() || cur.name); cur.minutes = Math.max(0.01, toMinutesValue(edtValue.value, edtUnit.value));
          if(currentSession[currentIndex]?.id===cur.id){ const newTotal = minsToSecs(cur.minutes); secondsLeft = Math.max(0, newTotal - elapsedSec); if(running) syncEnd(); }
          saveCurrentSession(); renderOutline(); buildProgress(); updateProgress(); renderCurrent(); updateStartBtnLabel(); markTimer(); syncSavedFromCurrent(); };
        li.querySelector('#edtSave').onclick = saveInline;
        [edtTitle, edtValue].forEach(el=> el.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); saveInline(); } }));
      });
    });

    // Delete
    outline.querySelectorAll('[data-act="delete"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const li = btn.closest('li[data-id]'); const id = li.dataset.id;
        const idx = currentSession.findIndex(x=>x.id===id); if(idx<0) return;
        if(!confirm('Delete this section?')) return;
        currentSession.splice(idx,1);
        if(currentIndex>=currentSession.length) currentIndex=Math.max(0,currentSession.length-1);
        secondsLeft=minsToSecs((currentSession[currentIndex]||{}).minutes||0);
        saveCurrentSession(); renderAll(); markTimer(); syncSavedFromCurrent();
      });
    });

    // Drag reorder with live placeholder
    let dragging = null;
    const makePh = (h, titleText)=>{ const ph = document.createElement('li'); ph.className='outline-row drop-placeholder'; ph.style.setProperty('--ph', `${Math.max(36,h)}px`); ph.innerHTML = `<div class="text-xs muted px-2 truncate">${escapeHtml(titleText||'')}</div>`; return ph; };
    outline.querySelectorAll('li[data-id]').forEach((li, idx)=>{
      li.addEventListener('dragstart', (e)=>{ if(li.classList.contains('editing')){ e.preventDefault(); return; } const titleText = (li.querySelector('button')?.textContent || '').trim(); dragging = { from: idx, el: li, placeholder: makePh(li.offsetHeight, titleText) }; li.classList.add('dragging'); li.after(dragging.placeholder); try{ e.dataTransfer.setData('text/plain', JSON.stringify({type:'outline-move', from: idx})); }catch{} e.dataTransfer.effectAllowed='move'; });
      li.addEventListener('dragend', ()=>{ li.classList.remove('dragging'); dragging?.placeholder?.remove(); dragging = null; });
      const onOver = (e)=>{ if(!dragging) return; e.preventDefault(); const r = li.getBoundingClientRect(); const before = e.clientY < (r.top + r.height/2); const ph = dragging.placeholder; if(before){ if(li.previousSibling !== ph) outline.insertBefore(ph, li); }else{ if(li.nextSibling !== ph) li.after(ph); } };
      li.addEventListener('dragover', onOver); li.addEventListener('dragenter', onOver);
    });
    outline.addEventListener('dragover', (e)=>{ if(!dragging) return; e.preventDefault(); if(!outline.contains(dragging.placeholder)) outline.appendChild(dragging.placeholder); });
    outline.addEventListener('drop', (e)=>{ if(!dragging) return; e.preventDefault(); const from = dragging.from; const rows = Array.from(outline.querySelectorAll('li.outline-row')); const phIndex = rows.indexOf(dragging.placeholder); const to = phIndex < 0 ? rows.length-1 : phIndex; const finalTo = (to > from) ? to - 1 : to;
      if(from !== finalTo && from >= 0 && finalTo >= 0){
        const [moved] = currentSession.splice(from,1); currentSession.splice(finalTo,0,moved);
        if(currentIndex === from) currentIndex = finalTo; else if(currentIndex > from && currentIndex <= finalTo) currentIndex -= 1; else if(currentIndex < from && currentIndex >= finalTo) currentIndex += 1;
        saveCurrentSession(); renderOutline(); buildProgress(); updateProgress(); renderCurrent(); syncSavedFromCurrent();
      }
      dragging.el.classList.remove('dragging'); dragging.placeholder.remove(); dragging = null;
    });

    if(totalMins) totalMins.textContent=`Total: ${Math.round(scheduleTotalSecs(currentSession)/60)} minutes`;
  }

  // Inline add
  addOutlineItemBtn.onclick = ()=>{ inlineAddRow.classList.remove('hidden'); addTitleInput.value=''; addMinsInput.value=''; addTitleInput.focus(); };
  addCancelBtn.onclick = ()=> inlineAddRow.classList.add('hidden');
  addConfirmBtn.onclick = ()=>{ const title=(addTitleInput.value||'').trim() || 'New section'; const mins=Math.max(0.25, Number(addMinsInput.value)||5); currentSession.push({ id:'S'+Date.now(), name:title, minutes:mins, links:[] }); inlineAddRow.classList.add('hidden'); saveCurrentSession(); renderAll(); markTimer(); syncSavedFromCurrent(); };

  /*************** Two-way sync glue (Home ↔ Saved) ***************/
  const getActiveOutlineId = ()=> (timerState && timerState.outlineId) ? timerState.outlineId : null;
  function syncSavedFromCurrent(){
    const activeId = getActiveOutlineId(); if(!activeId) return;

    // Find the outline object anywhere in the (possibly nested) structure
    function findDeep(id, arr){ for(const it of (arr||[])){ if(it?.id===id && it.sections) return it; if(it?.type==='folder' && it.children){ const r=findDeep(id, it.children); if(r) return r; } } return null; }
    const saved = findDeep(activeId, savedOutlines); if(!saved) return;

    const newSections = currentSession.map(sec=>{
      let sid = sec.id; if(!sid){ sid = 'S'+Date.now().toString(36)+Math.random().toString(36).slice(2,6); sec.id = sid; }
      return { id: sid, name: sec.name, minutes: sec.minutes, links: structuredClone(sec.links || []), desc: sectionNotes[sid] ?? '' };
    });
    saved.sections = newSections;
    saveOutlinesLocal(); renderHomeSavedBar(); touchCloud();
  }
  function syncCurrentFromSaved(outlineObj){
    const activeId = getActiveOutlineId(); if(!activeId || !outlineObj || outlineObj.id !== activeId) return;
    const oldActive = currentSession[currentIndex] || null; const oldActiveId = oldActive?.id || null; const oldActiveMins = Number(oldActive?.minutes || 0); const elapsedInActive = oldActiveId ? Math.max(0, minsToSecs(oldActiveMins) - secondsLeft) : 0;

    currentSession = (outlineObj.sections || []).map(s=>({ id: s.id || ('S'+Date.now().toString(36)+Math.random().toString(36).slice(2,6)), name: s.name, minutes: s.minutes, links: structuredClone(s.links || []) }));
    sectionNotes = {}; (outlineObj.sections || []).forEach(s=>{ if(s?.id) sectionNotes[s.id] = s.desc || ''; });

    let newIdx = 0, newLeft = 0;
    if(oldActiveId){ const i = currentSession.findIndex(x=>x.id===oldActiveId); if(i>=0){ newIdx = i; const newTotal = minsToSecs(currentSession[i].minutes || 0); newLeft = Math.max(0, newTotal - Math.min(elapsedInActive, newTotal)); } else { newIdx = Math.min(currentIndex, Math.max(0, currentSession.length-1)); newLeft = minsToSecs((currentSession[newIdx]||{}).minutes || 0); } }
    else { newIdx = Math.min(currentIndex, Math.max(0, currentSession.length-1)); newLeft = minsToSecs((currentSession[newIdx]||{}).minutes || 0); }

    currentIndex = newIdx; secondsLeft = newLeft; totalSessionSecs = scheduleTotalSecs(currentSession); if(running) syncEnd();
    saveCurrentSession(); saveNotes(); renderAll(); updateStartBtnLabel(); markTimer();
  }

  /*************** Saved Outlines module wiring ***************/
  const homeSavedScroller = $('#homeSavedScroller');
  function flattenOutlines(arr, out=[]){
    (arr||[]).forEach(it=>{
      if(it?.type==='folder'){ flattenOutlines(it.children||[], out); }
      else if(it?.sections) out.push(it);
    });
    return out;
  }
  function renderHomeSavedBar(){
    const activeId = (timerState && timerState.outlineId) || null;
    const flat = flattenOutlines(savedOutlines, []);
    homeSavedScroller.innerHTML =
      (flat.length
        ? flat.map(o=>`
            <button type="button"
                    class="chip ${o.id===activeId ? 'chip-active' : ''}"
                    data-oid="${escapeHtml(o.id)}"
                    title="${escapeHtml(o.title || 'Outline')}">
              ${escapeHtml(o.title || 'Untitled')}
            </button>`).join('')
        : `<div class="text-xs muted">No saved outlines yet.</div>`);
    homeSavedScroller.querySelectorAll('[data-oid]').forEach(btn=>{
      btn.onclick = ()=>{ const o = flat.find(x=>x.id===btn.dataset.oid); if(o){ applyOutlineToCurrent(o); requestAnimationFrame(renderHomeSavedBar); } };
    });
  }
  function applyOutlineToCurrent(outlineObj){
    const clone = outlineObj.sections.map(s=>({ id:s.id||('S'+Math.random().toString(16).slice(2)), name:s.name, minutes:s.minutes, links:structuredClone(s.links||[]) }));
    currentSession = clone; sectionNotes = {}; clone.forEach(sec=>{ const src = outlineObj.sections.find(ss=>ss.id===sec.id); if(src && src.desc!=null) sectionNotes[sec.id] = src.desc; });
    timerState = { sessionStarted:false, running:false, currentIndex:0, secondsLeft:minsToSecs((clone[0]||{}).minutes||0), outlineId: outlineObj.id, lastSyncTs: Date.now(), awaitingNext:false };
    awaitingNext=false; hideNextGate(); saveCurrentSession(); saveNotes(); saveTimerLocal(); renderAll(); updateStartBtnLabel();
  }

  const { renderSavedOutlines } = setupSavedOutlines({
    getSavedOutlines: ()=> savedOutlines,
    setSavedOutlines: (arr)=>{ savedOutlines = arr; },
    saveOutlinesLocal,
    getWidgetShelf: ()=> widgetShelf,
    setWidgetShelf: (arr)=>{ widgetShelf = arr; saveShelf(); },
    applyOutline: applyOutlineToCurrent,
    touchCloud,
    renderHomeSavedBar,
    getActiveOutlineId,
    syncCurrentFromSaved
  });

  /*************** Auth modal ***************/
  const authOpenBtn = $('#authOpenBtn'); const userBadge = $('#userBadge'); const userEmail = $('#userEmail'); const signOutBtn = $('#signOutBtn');
  const authModal = $('#authModal'); const authTitle=$('#authTitle'); const authSubtitle=$('#authSubtitle');
  const emailInput=$('#emailInput'); const passInput=$('#passInput');
  const googleBtn=$('#googleBtn'); const emailSignInBtn=$('#emailSignInBtn'); const emailSignUpBtn=$('#emailSignUpBtn'); const emailResetBtn=$('#emailResetBtn');
  const signinRow=$('#signinRow'); const signupRow=$('#signupRow'); const toggleAuthMode=$('#toggleAuthMode');

  let authMode='signin';
  function showModal(modal){ modal.classList.remove('hidden'); modal.setAttribute('aria-hidden','false'); }
  function hideModal(modal){ modal.classList.add('hidden'); modal.setAttribute('aria-hidden','true'); }
  function setAuthMode(mode){
    authMode=mode; const isSignUp = mode==='signup';
    signinRow.classList.toggle('hidden', isSignUp);
    signupRow.classList.toggle('hidden', !isSignUp);
    toggleAuthMode.textContent = isSignUp ? 'Already have an account? Sign in' : 'New here? Create an account';
    authTitle.textContent = isSignUp ? 'Create your account' : 'Welcome back';
    authSubtitle.textContent = isSignUp ? 'Make an account to enable cloud sync.' : 'Sign in to sync your data across devices.';
  }
  toggleAuthMode.onclick = ()=> setAuthMode(authMode==='signin'?'signup':'signin');
  authOpenBtn.onclick = ()=>{ emailInput.value=''; passInput.value=''; setAuthMode('signin'); showModal(authModal); };
  authModal.addEventListener('click', (e)=>{ if(e.target.dataset.close==='1') hideModal(authModal); });
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ hideModal(authModal); hideModal(settingsModal); if(!focusOverlay.classList.contains('hidden')) hideFocus(); } });

  googleBtn.onclick = ()=> signInWithPopup(auth, provider).catch(err=> alert(err.message||'Google sign-in failed'));
  emailSignInBtn.onclick = async ()=>{ try{ await signInWithEmailAndPassword(auth, emailInput.value.trim(), passInput.value); } catch(e){ alert(e.message||'Sign-in failed'); } };
  const emailSignUpBtnEl = document.getElementById('emailSignUpBtn'); if(emailSignUpBtnEl){ emailSignUpBtnEl.onclick = async ()=>{ try{ await createUserWithEmailAndPassword(auth, emailInput.value.trim(), passInput.value); } catch(e){ alert(e.message||'Sign-up failed'); } }; }
  emailResetBtn.onclick = async ()=>{ try{ if(!emailInput.value.trim()) return alert('Enter your email first.'); await sendPasswordResetEmail(auth, emailInput.value.trim()); alert('Reset email sent.'); } catch(e){ alert(e.message||'Reset failed'); } };
  signOutBtn.onclick = ()=> signOut(auth);

  async function pushLocalToCloudIfMissing(user){
    try{
      const snap = await getDoc(userDocRef(user.uid));
      if(!snap.exists()){
        await setDoc(userDocRef(user.uid), {
          currentSession, notes: sectionNotes, prefs, widgetShelf, savedOutlines, timer: timerState, updatedAt: serverTimestamp()
        }, { merge:true });
      }
    }catch{}
  }

  onAuthStateChanged(auth, async (user)=>{
    currentUser = user || null;
    if(user){
      authOpenBtn.classList.add('hidden'); userBadge.classList.remove('hidden'); userEmail.textContent = user.email || user.uid; setCloudMode('Syncing…'); hideModal(authModal);
      try{
        await pushLocalToCloudIfMissing(user);
        const snap = await getDoc(userDocRef(user.uid));
        if(snap.exists()){
          const d = snap.data()||{};
          if(d.currentSession) currentSession = d.currentSession;
          if(d.notes) sectionNotes = d.notes;
          if(d.prefs) prefs = d.prefs;
          if(d.widgetShelf) widgetShelf = d.widgetShelf;
          if(d.savedOutlines) savedOutlines = d.savedOutlines;
          if(d.timer) timerState = d.timer;
          applyTheme(prefs.theme||{}); applySplitRatio(prefs.splitRatio||56);
          setTimerFromState(timerState); renderAll(); renderHomeSavedBar(); setCloudMode('Saved to cloud ✓');
          if(prefs.focusDefault) showFocus();
        } else { setCloudMode('Cloud sync on'); if(prefs.focusDefault) showFocus(); }
      }catch{ setLocalMode('Cloud read failed'); if(prefs.focusDefault) showFocus(); }
    } else {
      authOpenBtn.classList.remove('hidden'); userBadge.classList.add('hidden'); setLocalMode('Local mode'); if(prefs.focusDefault) showFocus();
    }
  });

  /*************** Settings modal ***************/
  const settingsModal = $('#settingsModal');
  const setBg=$('#setBg'), setFg=$('#setFg'), setAccent=$('#setAccent'), setBorder=$('#setBorder'), setBorderW=$('#setBorderW'), setFocusDefault=$('#setFocusDefault');
  const settingsSaveBtn=$('#settingsSaveBtn'); const settingsDefaultBtn=$('#settingsDefaultBtn');
  const ringToneSel=$('#ringTone'), ringDur=$('#ringDur'), ringVol=$('#ringVol'), ringPreview=$('#ringPreview'), ringVolVal=$('#ringVolVal');

  function applyTheme(t){
    document.documentElement.style.setProperty('--bg', t.bg || '#ffffff');
    document.documentElement.style.setProperty('--fg', t.fg || '#0f172a');
    document.documentElement.style.setProperty('--accent', t.accent || '#0ea5e9');
    document.documentElement.style.setProperty('--border', t.border || '#94a3b8');
    document.documentElement.style.setProperty('--panel', t.panel || '#ffffff');
    document.documentElement.style.setProperty('--panel-muted', t.panelMuted || '#f8fafc');
    document.documentElement.style.setProperty('--borderW', (t.borderW ?? 2) + 'px');
  }
  function openSettings(){
    setBg.value = prefs.theme?.bg || '#ffffff';
    setFg.value = prefs.theme?.fg || '#0f172a';
    setAccent.value = prefs.theme?.accent || '#0ea5e9';
    setBorder.value = prefs.theme?.border || '#94a3b8';
    setBorderW.value = String(prefs.theme?.borderW ?? 2);
    setFocusDefault.checked = !!prefs.focusDefault;

    ringToneSel.value = prefs.sound?.name || 'chime';
    ringDur.value = String(prefs.sound?.duration ?? 800);
    ringVol.value = String(prefs.sound?.volume ?? 0.12);
    ringVolVal.textContent = Number(ringVol.value).toFixed(2);

    showModal(settingsModal);
  }
  function closeSettings(){ hideModal(settingsModal); }
  document.querySelectorAll('#settingsModal [data-close="1"]').forEach(b=> b.addEventListener('click', closeSettings));
  settingsModal.addEventListener('click', (e)=>{ if(e.target.dataset.close==='1') closeSettings(); });
  $('#settingsBtn').onclick = openSettings;

  // Live theme preview + autosave
  [setBg,setFg,setAccent,setBorder,setBorderW].forEach(inp=>{
    inp.addEventListener('input', ()=>{
      prefs.theme = { bg:setBg.value, fg:setFg.value, accent:setAccent.value, border:setBorder.value, borderW:Math.max(0, Number(setBorderW.value)||2) };
      applyTheme(prefs.theme); savePrefs();
    });
  });
  setFocusDefault.addEventListener('change', ()=>{ prefs.focusDefault = !!setFocusDefault.checked; savePrefs(); });

  // Color picker: close when clicking anywhere else in the modal
  let activeColor = null;
  [setBg,setFg,setAccent,setBorder].forEach(inp=>{
    inp.addEventListener('focus', ()=> activeColor=inp);
  });
  settingsModal.addEventListener('mousedown', (e)=>{
    if(activeColor && e.target !== activeColor && !activeColor.contains(e.target)){ activeColor.blur(); activeColor=null; }
  });

  // Sound preferences (live)
  ringToneSel.addEventListener('change', ()=>{ prefs.sound.name = ringToneSel.value; savePrefs(); });
  ringDur.addEventListener('input', ()=>{ prefs.sound.duration = Math.max(100, Number(ringDur.value)||800); savePrefs(); });
  ringVol.addEventListener('input', ()=>{ prefs.sound.volume = Math.max(0, Math.min(1, Number(ringVol.value)||0.12)); ringVolVal.textContent = Number(prefs.sound.volume).toFixed(2); savePrefs(); });
  ringPreview.addEventListener('click', ()=> playAlert({ name:ringToneSel.value, duration:Number(ringDur.value), volume:Number(ringVol.value) }) );

  // Default button
  settingsDefaultBtn.onclick = ()=>{
    prefs.theme = { bg:'#ffffff', fg:'#0f172a', accent:'#0ea5e9', border:'#94a3b8', borderW:2 };
    prefs.sound = { name:'chime', duration:800, volume:0.12 };
    prefs.focusDefault = false;
    applyTheme(prefs.theme); savePrefs(); openSettings();
  };

  // Save (kept for completeness)
  settingsSaveBtn.onclick = ()=>{ savePrefs(); closeSettings(); };
  applyTheme(prefs.theme||{});

  /*************** Focus helpers ***************/
  function renderFocusLinks(){
    const sec = currentSectionRef(); const arr = sec?.links || [];
    focusLinksDiv.innerHTML = arr.length ? arr.map((w,i)=>`
      <div class="widget" data-flink-idx="${i}">
        <div class="link-card section-link" data-idx="${i}">
          ${w.icon==='img' && w.img ? `<img src="${escapeHtml(w.img)}" alt="" class="rounded-[4px] object-cover" draggable="false" style="width:18px;height:18px;"/>` : `<span class="link-icon">${escapeHtml(w.emoji||'🔗')}</span>`}
          <span class="truncate max-w-[14rem]">${escapeHtml(w.label||'Untitled')}</span>
        </div>
      </div>`).join('') : `<div class="text-xs muted">No links for this section.</div>`;
    focusLinksDiv.querySelectorAll('.section-link').forEach(card=>{
      card.addEventListener('click', ()=>{ const i = Number(card.dataset.idx); const target = (sec?.links||[])[i]; if(!target) return; const url = normalizeUrl(target.url||''); if(url) window.open(url, '_blank', 'noopener'); });
    });
  }
  function renderFocusUI(){
    const sec = currentSession[currentIndex]; const count = currentSession.length;
    if(!sec){ focusTitleEl.textContent = '—'; focusMetaEl.textContent = ''; focusDescEl.textContent = ''; }
    else{ focusTitleEl.textContent = sec.name || 'Untitled'; focusMetaEl.textContent = `Section ${Math.min(currentIndex+1,count)} of ${count} • ${(sec.minutes||0)}m`; const note = sectionNotes[sec.id] || ''; focusDescEl.textContent = note ? note : 'No notes for this section.'; }
    buildFocusProgress(); renderFocusLinks(); setClockText(secsToClock(secondsLeft)); updateClockColor(); updateStartBtnLabel();
  }
  function showFocus(){ renderFocusUI(); focusOverlay.classList.remove('hidden'); }
  function hideFocus(){ focusOverlay.classList.add('hidden'); }
  if(focusModeBtn) focusModeBtn.onclick = showFocus;
  if(focusExitBtn) focusExitBtn.onclick = hideFocus;

  /*************** Initial render ***************/
  function renderCurrent(){
    const s=currentSession[currentIndex]; 
    if(!s){ currentTitleEl.textContent='—'; currentDurDisp.textContent='0m'; sectionDescEl.value=''; linksDiv.innerHTML=''; renderFocusUI(); return; }
    currentTitleEl.textContent = s.name || 'Untitled';
    currentDurDisp.textContent = `${Number(s.minutes||0)}m`;
    sectionNotes[s.id] = sectionNotes[s.id] || '';
    sectionDescEl.value = sectionNotes[s.id];
    sectionDescEl.disabled = !isEditingSection;
    renderCurrentLinks(); setClockText(secsToClock(secondsLeft)); renderFocusUI();
  }
  function renderAll(){ renderOutline(); buildProgress(); updateProgress(); renderCurrent(); }

  /*************** Ringtone (WebAudio) ***************/
  let ctx = null;
  function unlockAudio(){ try{ if(!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)(); if(ctx.state === 'suspended') ctx.resume(); }catch{} }
  ['click','keydown','touchstart','pointerdown'].forEach(ev=>{ document.addEventListener(ev, unlockAudio, { once:true, passive:true }); });

  function tone(freq, durMs, type='sine', volume=0.12, startAt=0){
    if(!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    const t0 = ctx.currentTime + startAt;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.00001, t0);
    g.gain.exponentialRampToValueAtTime(Math.max(0.00002, volume), t0 + 0.02);
    g.gain.exponentialRampToValueAtTime(0.00001, t0 + (durMs/1000));
    osc.connect(g); g.connect(ctx.destination);
    osc.start(t0); osc.stop(t0 + (durMs/1000) + 0.02);
    return { osc, g };
  }
  function playAlert(opts){
    const name = (opts?.name) || (prefs.sound?.name || 'chime');
    const dur  = Math.max(100, (opts?.duration ?? prefs.sound?.duration ?? 800));
    const vol  = Math.max(0, Math.min(1, (opts?.volume ?? prefs.sound?.volume ?? 0.12)));
    unlockAudio();

    // Simple voicings (keep CPU/lightweight)
    if(name==='ping'){
      tone(1200, dur, 'sine', vol*0.8);
    }else if(name==='bell'){
      tone(880, dur,   'sine',  vol*0.45);
      tone(1320, dur,  'sine',  vol*0.25);
      tone(1760, dur,  'sine',  vol*0.12);
    }else if(name==='digital'){
      tone(880, dur*0.5, 'square', vol*0.5, 0);
      tone(660, dur*0.5, 'square', vol*0.5, dur*0.5/1000);
    }else { // chime (default)
      const seg = dur/3;
      tone(880, seg, 'sine', vol*0.7, 0);
      tone(660, seg, 'sine', vol*0.7, seg/1000);
      tone(990, seg, 'sine', vol*0.6, 2*seg/1000);
    }
  }

  // Demo progress on Overview tab
  const demoPlay = document.getElementById('demoPlay');
  const demoReset = document.getElementById('demoReset');
  const demoFill = document.getElementById('demoFill');
  const demoPct = document.getElementById('demoPct');
  let demoId=null, demoVal=0;
  if(demoPlay){
    demoPlay.onclick = ()=>{ if(demoId) return; demoId = setInterval(()=>{ demoVal=Math.min(100, demoVal+2); demoFill.style.width=demoVal+'%'; demoPct.textContent=demoVal+'%'; if(demoVal>=100){ clearInterval(demoId); demoId=null; playAlert(); } }, 60); };
    demoReset.onclick = ()=>{ if(demoId){ clearInterval(demoId); demoId=null; } demoVal=0; demoFill.style.width='0%'; demoPct.textContent='0%'; };
  }

  setTimerFromState(timerState); renderAll(); renderHomeSavedBar();
  showTab('overviewTab'); // default landing
</script>

<!-- Optional Pricing tab (unchanged) -->
<script src="./pricing-tab.js"></script>
</body>
</html>
